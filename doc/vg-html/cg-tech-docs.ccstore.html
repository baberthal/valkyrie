<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>2.3. Storing cost-centres</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="cg-tech-docs.html" title="2. How Cachegrind works">
<link rel="previous" href="cg-tech-docs.costcentres.html" title="2.2. Cost centres">
<link rel="next" href="cg-tech-docs.instrum.html" title="2.4. Instrumentation">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="cg-tech-docs.costcentres.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="cg-tech-docs.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">2. How Cachegrind works</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="cg-tech-docs.instrum.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="cg-tech-docs.ccstore"></a>2.3. Storing cost-centres</h2></div></div>
<div></div>
</div>
<p>Cost centres are stored in a way that makes them very cheap
to lookup, which is important since one is looked up for every
original x86 instruction executed.</p>
<p>Valgrind does JIT translations at the basic block level,
and cost centres are also setup and stored at the basic block
level.  By doing things carefully, we store all the cost centres
for a basic block in a contiguous array, and lookup comes almost
for free.</p>
<p>Consider this part of a basic block (for exposition
purposes, pretend it's an entire basic block):</p>
<pre class="programlisting">
movl $0x0,%eax
movl $0x99, -4(%ebp)</pre>
<p>The translation to UCode looks like this:</p>
<pre class="programlisting">
MOVL      $0x0, t20
PUTL      t20, %EAX
INCEIPo   $5

LEA1L     -4(t4), t14
MOVL      $0x99, t18
STL       t18, (t14)
INCEIPo   $7</pre>
<p>The first step is to allocate the cost centres.  This
requires a preliminary pass to count how many x86 instructions
were in the basic block, and their types (and thus sizes).  UCode
translations for single x86 instructions are delimited by the
<tt class="computeroutput">INCEIPo</tt> instruction, the
argument of which gives the byte size of the instruction (note
that lazy INCEIP updating is turned off to allow this).</p>
<p>We can tell if an x86 instruction references memory by
looking for <tt class="computeroutput">LDL</tt> and
<tt class="computeroutput">STL</tt> UCode instructions, and thus
what kind of cost centre is required.  From this we can determine
how many cost centres we need for the basic block, and their
sizes.  We can then allocate them in a single array.</p>
<p>Consider the example code above.  After the preliminary
pass, we know we need two cost centres, one
<tt class="computeroutput">iCC</tt> and one
<tt class="computeroutput">dCC</tt>.  So we allocate an array to
store these which looks like this:</p>
<pre class="programlisting">
|(uninit)|      tag         (1 byte)
|(uninit)|      instr_size  (1 bytes)
|(uninit)|      (padding)   (2 bytes)
|(uninit)|      instr_addr  (4 bytes)
|(uninit)|      I.a         (8 bytes)
|(uninit)|      I.m1        (8 bytes)
|(uninit)|      I.m2        (8 bytes)

|(uninit)|      tag         (1 byte)
|(uninit)|      instr_size  (1 byte)
|(uninit)|      data_size   (1 byte)
|(uninit)|      (padding)   (1 byte)
|(uninit)|      instr_addr  (4 bytes)
|(uninit)|      I.a         (8 bytes)
|(uninit)|      I.m1        (8 bytes)
|(uninit)|      I.m2        (8 bytes)
|(uninit)|      D.a         (8 bytes)
|(uninit)|      D.m1        (8 bytes)
|(uninit)|      D.m2        (8 bytes)</pre>
<p>(We can see now why we need tags to distinguish between the
two types of cost centres.)</p>
<p>We also record the size of the array.  We look up the debug
info of the first instruction in the basic block, and then stick
the array into a table indexed by filename and function name.
This makes it easy to dump the information quickly to file at the
end.</p>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="cg-tech-docs.costcentres.html">&lt;&lt; 2.2. Cost centres</a> </td>
<td width="20%" align="center"><a accesskey="u" href="cg-tech-docs.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="cg-tech-docs.instrum.html">2.4. Instrumentation &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
