<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>5.3. cg_annotate options</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="cg-manual.html" title="5. Cachegrind: a cache profiler">
<link rel="previous" href="cg-manual.profile.html" title="5.2. Profiling programs">
<link rel="next" href="ms-manual.html" title="6. Massif: a heap profiler">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="cg-manual.profile.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="cg-manual.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">5. Cachegrind: a cache profiler</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="ms-manual.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="cg-manual.annopts"></a>5.3. <tt class="computeroutput">cg_annotate</tt> options</h2></div></div>
<div></div>
</div>
<div class="itemizedlist"><ul type="disc">
<li>
<p><a name="pid"></a><tt class="computeroutput">--pid</tt></p>
<p>Indicates which
    <tt class="computeroutput">cachegrind.out.pid</tt> file to
    read.  Not actually an option -- it is required.</p>
</li>
<li>
<p><tt class="computeroutput">-h, --help</tt></p>
<p><tt class="computeroutput">-v, --version</tt></p>
<p>Help and version, as usual.</p>
</li>
<li>
<p><a name="sort"></a><tt class="computeroutput">--sort=A,B,C</tt> [default:
    order in
    <tt class="computeroutput">cachegrind.out.pid</tt>]</p>
<p>Specifies the events upon which the sorting of the
    function-by-function entries will be based.  Useful if you
    want to concentrate on eg. I cache misses
    (<tt class="computeroutput">--sort=I1mr,I2mr</tt>), or D
    cache misses
    (<tt class="computeroutput">--sort=D1mr,D2mr</tt>), or L2
    misses
    (<tt class="computeroutput">--sort=D2mr,I2mr</tt>).</p>
</li>
<li>
<p><a name="show"></a><tt class="computeroutput">--show=A,B,C</tt> [default:
    all, using order in
    <tt class="computeroutput">cachegrind.out.pid</tt>]</p>
<p>Specifies which events to show (and the column
    order). Default is to use all present in the
    <tt class="computeroutput">cachegrind.out.pid</tt> file (and
    use the order in the file).</p>
</li>
<li>
<p><a name="threshold"></a><tt class="computeroutput">--threshold=X</tt>
    [default: 99%]</p>
<p>Sets the threshold for the function-by-function
    summary.  Functions are shown that account for more than X%
    of the primary sort event.  If auto-annotating, also affects
    which files are annotated.</p>
<p>Note: thresholds can be set for more than one of the
    events by appending any events for the
    <tt class="computeroutput">--sort</tt> option with a colon
    and a number (no spaces, though).  E.g. if you want to see
    the functions that cover 99% of L2 read misses and 99% of L2
    write misses, use this option:</p>
<p><tt class="computeroutput">--sort=D2mr:99,D2mw:99</tt></p>
</li>
<li>
<p><a name="auto"></a><tt class="computeroutput">--auto=no</tt> [default]</p>
<p><tt class="computeroutput">--auto=yes</tt></p>
<p>When enabled, automatically annotates every file that
    is mentioned in the function-by-function summary that can be
    found.  Also gives a list of those that couldn't be found.</p>
</li>
<li>
<p><a name="context"></a><tt class="computeroutput">--context=N</tt> [default:
    8]</p>
<p>Print N lines of context before and after each
    annotated line.  Avoids printing large sections of source
    files that were not executed.  Use a large number
    (eg. 10,000) to show all source lines.</p>
</li>
<li>
<p><a name="include"></a><tt class="computeroutput">-I=&lt;dir&gt;,
      --include=&lt;dir&gt;</tt> [default: empty
      string]</p>
<p>Adds a directory to the list in which to search for
    files.  Multiple -I/--include options can be given to add
    multiple directories.</p>
</li>
</ul></div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="id4829074"></a>5.3.1. Warnings</h3></div></div>
<div></div>
</div>
<p>There are a couple of situations in which
<tt class="computeroutput">cg_annotate</tt> issues
warnings.</p>
<div class="itemizedlist"><ul type="disc">
<li><p>If a source file is more recent than the
    <tt class="computeroutput">cachegrind.out.pid</tt> file.
    This is because the information in
    <tt class="computeroutput">cachegrind.out.pid</tt> is only
    recorded with line numbers, so if the line numbers change at
    all in the source (eg.  lines added, deleted, swapped), any
    annotations will be incorrect.</p></li>
<li><p>If information is recorded about line numbers past the
    end of a file.  This can be caused by the above problem,
    ie. shortening the source file while using an old
    <tt class="computeroutput">cachegrind.out.pid</tt> file.  If
    this happens, the figures for the bogus lines are printed
    anyway (clearly marked as bogus) in case they are
    important.</p></li>
</ul></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="id4830776"></a>5.3.2. Things to watch out for</h3></div></div>
<div></div>
</div>
<p>Some odd things that can occur during annotation:</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p>If annotating at the assembler level, you might see
    something like this:</p>
<pre class="programlisting">
      1    0    0  .    .    .  .    .    .          leal -12(%ebp),%eax
      1    0    0  .    .    .  1    0    0          movl %eax,84(%ebx)
      2    0    0  0    0    0  1    0    0          movl $1,-20(%ebp)
      .    .    .  .    .    .  .    .    .          .align 4,0x90
      1    0    0  .    .    .  .    .    .          movl $.LnrB,%eax
      1    0    0  .    .    .  1    0    0          movl %eax,-16(%ebp)</pre>
<p>How can the third instruction be executed twice when
    the others are executed only once?  As it turns out, it
    isn't.  Here's a dump of the executable, using
    <tt class="computeroutput">objdump -d</tt>:</p>
<pre class="programlisting">
      8048f25:       8d 45 f4                lea    0xfffffff4(%ebp),%eax
      8048f28:       89 43 54                mov    %eax,0x54(%ebx)
      8048f2b:       c7 45 ec 01 00 00 00    movl   $0x1,0xffffffec(%ebp)
      8048f32:       89 f6                   mov    %esi,%esi
      8048f34:       b8 08 8b 07 08          mov    $0x8078b08,%eax
      8048f39:       89 45 f0                mov    %eax,0xfffffff0(%ebp)</pre>
<p>Notice the extra <tt class="computeroutput">mov
    %esi,%esi</tt> instruction.  Where did this come
    from?  The GNU assembler inserted it to serve as the two
    bytes of padding needed to align the <tt class="computeroutput">movl
    $.LnrB,%eax</tt> instruction on a four-byte
    boundary, but pretended it didn't exist when adding debug
    information.  Thus when Valgrind reads the debug info it
    thinks that the <tt class="computeroutput">movl
    $0x1,0xffffffec(%ebp)</tt> instruction covers the
    address range 0x8048f2b--0x804833 by itself, and attributes
    the counts for the <tt class="computeroutput">mov
    %esi,%esi</tt> to it.</p>
</li>
<li>
<p>Inlined functions can cause strange results in the
    function-by-function summary.  If a function
    <tt class="computeroutput">inline_me()</tt> is defined in
    <tt class="filename">foo.h</tt> and inlined in the functions
    <tt class="computeroutput">f1()</tt>,
    <tt class="computeroutput">f2()</tt> and
    <tt class="computeroutput">f3()</tt> in
    <tt class="filename">bar.c</tt>, there will not be a
    <tt class="computeroutput">foo.h:inline_me()</tt> function
    entry.  Instead, there will be separate function entries for
    each inlining site, ie.
    <tt class="computeroutput">foo.h:f1()</tt>,
    <tt class="computeroutput">foo.h:f2()</tt> and
    <tt class="computeroutput">foo.h:f3()</tt>.  To find the
    total counts for
    <tt class="computeroutput">foo.h:inline_me()</tt>, add up
    the counts from each entry.</p>
<p>The reason for this is that although the debug info
    output by gcc indicates the switch from
    <tt class="filename">bar.c</tt> to <tt class="filename">foo.h</tt>, it
    doesn't indicate the name of the function in
    <tt class="filename">foo.h</tt>, so Valgrind keeps using the old
    one.</p>
</li>
<li><p>Sometimes, the same filename might be represented with
    a relative name and with an absolute name in different parts
    of the debug info, eg:
    <tt class="filename">/home/user/proj/proj.h</tt> and
    <tt class="filename">../proj.h</tt>.  In this case, if you use
    auto-annotation, the file will be annotated twice with the
    counts split between the two.</p></li>
<li><p>Files with more than 65,535 lines cause difficulties
    for the stabs debug info reader.  This is because the line
    number in the <tt class="computeroutput">struct nlist</tt>
    defined in <tt class="filename">a.out.h</tt> under Linux is only a
    16-bit value.  Valgrind can handle some files with more than
    65,535 lines correctly by making some guesses to identify
    line number overflows.  But some cases are beyond it, in
    which case you'll get a warning message explaining that
    annotations for the file might be incorrect.</p></li>
<li><p>If you compile some files with
    <tt class="computeroutput">-g</tt> and some without, some
    events that take place in a file without debug info could be
    attributed to the last line of a file with debug info
    (whichever one gets placed before the non-debug-info file in
    the executable).</p></li>
</ul></div>
<p>This list looks long, but these cases should be fairly
rare.</p>
<p><b>Note: </b><tt class="computeroutput">stabs</tt> is not an easy
  format to read.  If you come across bizarre annotations that
  look like might be caused by a bug in the stabs reader, please
  let us know.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="id4844448"></a>5.3.3. Accuracy</h3></div></div>
<div></div>
</div>
<p>Valgrind's cache profiling has a number of
shortcomings:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>It doesn't account for kernel activity -- the effect of
    system calls on the cache contents is ignored.</p></li>
<li><p>It doesn't account for other process activity (although
    this is probably desirable when considering a single
    program).</p></li>
<li><p>It doesn't account for virtual-to-physical address
    mappings; hence the entire simulation is not a true
    representation of what's happening in the
    cache.</p></li>
<li><p>It doesn't account for cache misses not visible at the
    instruction level, eg. those arising from TLB misses, or
    speculative execution.</p></li>
<li><p>Valgrind's custom threads implementation will schedule
    threads differently to the standard one.  This could warp the
    results for threaded programs.</p></li>
<li>
<p>The instructions <tt class="computeroutput">bts</tt>,
    <tt class="computeroutput">btr</tt> and
    <tt class="computeroutput">btc</tt> will incorrectly be
    counted as doing a data read if both the arguments are
    registers, eg:</p>
<pre class="programlisting">
    btsl %eax, %edx</pre>
<p>This should only happen rarely.</p>
</li>
<li><p>FPU instructions with data sizes of 28 and 108 bytes
    (e.g.  <tt class="computeroutput">fsave</tt>) are treated as
    though they only access 16 bytes.  These instructions seem to
    be rare so hopefully this won't affect accuracy much.</p></li>
</ul></div>
<p>Another thing worth nothing is that results are very
sensitive.  Changing the size of the
<tt class="filename">valgrind.so</tt> file, the size of the program
being profiled, or even the length of its name can perturb the
results.  Variations will be small, but don't expect perfectly
repeatable results if your program changes at all.</p>
<p>While these factors mean you shouldn't trust the results to
be super-accurate, hopefully they should be close enough to be
useful.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="id4835554"></a>5.3.4. Todo</h3></div></div>
<div></div>
</div>
<div class="itemizedlist"><ul type="disc"><li><p>Program start-up/shut-down calls a lot of functions
    that aren't interesting and just complicate the output.
    Would be nice to exclude these somehow.</p></li></ul></div>
</div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="cg-manual.profile.html">&lt;&lt; 5.2. Profiling programs</a> </td>
<td width="20%" align="center"><a accesskey="u" href="cg-manual.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="ms-manual.html">6. Massif: a heap profiler &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
