<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>3.3. Explanation of error messages from Memcheck</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="mc-manual.html" title="3. Memcheck: a heavyweight memory checker">
<link rel="previous" href="mc-manual.flags.html" title="3.2. Command-line flags specific to Memcheck">
<link rel="next" href="mc-manual.suppfiles.html" title="3.4. Writing suppressions files">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="mc-manual.flags.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="mc-manual.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">3. Memcheck: a heavyweight memory checker</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="mc-manual.suppfiles.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="mc-manual.errormsgs"></a>3.3. Explanation of error messages from Memcheck</h2></div></div>
<div></div>
</div>
<p>Despite considerable sophistication under the hood,
Memcheck can only really detect two kinds of errors, use of
illegal addresses, and use of undefined values.  Nevertheless,
this is enough to help you discover all sorts of
memory-management nasties in your code.  This section presents a
quick summary of what error messages mean.  The precise behaviour
of the error-checking machinery is described in <a href="mc-manual.machine.html">Details of Memcheck's checking machinery</a>.</p>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.badrw"></a>3.3.1. Illegal read / Illegal write errors</h3></div></div>
<div></div>
</div>
<p>For example:</p>
<pre class="programlisting">
Invalid read of size 4
   at 0x40F6BBCC: (within /usr/lib/libpng.so.2.1.0.9)
   by 0x40F6B804: (within /usr/lib/libpng.so.2.1.0.9)
   by 0x40B07FF4: read_png_image__FP8QImageIO (kernel/qpngio.cpp:326)
   by 0x40AC751B: QImageIO::read() (kernel/qimage.cpp:3621)
 Address 0xBFFFF0E0 is not stack'd, malloc'd or free'd
</pre>
<p>This happens when your program reads or writes memory at a
place which Memcheck reckons it shouldn't.  In this example, the
program did a 4-byte read at address 0xBFFFF0E0, somewhere within
the system-supplied library libpng.so.2.1.0.9, which was called
from somewhere else in the same library, called from line 326 of
<tt class="filename">qpngio.cpp</tt>, and so on.</p>
<p>Memcheck tries to establish what the illegal address might
relate to, since that's often useful.  So, if it points into a
block of memory which has already been freed, you'll be informed
of this, and also where the block was free'd at.  Likewise, if it
should turn out to be just off the end of a malloc'd block, a
common result of off-by-one-errors in array subscripting, you'll
be informed of this fact, and also where the block was
malloc'd.</p>
<p>In this example, Memcheck can't identify the address.
Actually the address is on the stack, but, for some reason, this
is not a valid stack address -- it is below the stack pointer,
<tt class="literal">%esp</tt>, and that isn't allowed.  In this
particular case it's probably caused by gcc generating invalid
code, a known bug in various flavours of gcc.</p>
<p>Note that Memcheck only tells you that your program is
about to access memory at an illegal address.  It can't stop the
access from happening.  So, if your program makes an access which
normally would result in a segmentation fault, you program will
still suffer the same fate -- but you will get a message from
Memcheck immediately prior to this.  In this particular example,
reading junk on the stack is non-fatal, and the program stays
alive.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.uninitvals"></a>3.3.2. Use of uninitialised values</h3></div></div>
<div></div>
</div>
<p>For example:</p>
<pre class="programlisting">
Conditional jump or move depends on uninitialised value(s)
   at 0x402DFA94: _IO_vfprintf (_itoa.h:49)
   by 0x402E8476: _IO_printf (printf.c:36)
   by 0x8048472: main (tests/manuel1.c:8)
</pre>
<p>An uninitialised-value use error is reported when your
program uses a value which hasn't been initialised -- in other
words, is undefined.  Here, the undefined value is used somewhere
inside the printf() machinery of the C library.  This error was
reported when running the following small program:</p>
<pre class="programlisting">
int main()
{
  int x;
  printf ("x = %d\n", x);
}</pre>
<p>It is important to understand that your program can copy
around junk (uninitialised) data to its heart's content.
Memcheck observes this and keeps track of the data, but does not
complain.  A complaint is issued only when your program attempts
to make use of uninitialised data.  In this example, x is
uninitialised.  Memcheck observes the value being passed to
<tt class="literal">_IO_printf</tt> and thence to
<tt class="literal">_IO_vfprintf</tt>, but makes no comment.  However,
_IO_vfprintf has to examine the value of x so it can turn it into
the corresponding ASCII string, and it is at this point that
Memcheck complains.</p>
<p>Sources of uninitialised data tend to be:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Local variables in procedures which have not been
    initialised, as in the example above.</p></li>
<li><p>The contents of malloc'd blocks, before you write
    something there.  In C++, the new operator is a wrapper round
    malloc, so if you create an object with new, its fields will
    be uninitialised until you (or the constructor) fill them in,
    which is only Right and Proper.</p></li>
</ul></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.badfrees"></a>3.3.3. Illegal frees</h3></div></div>
<div></div>
</div>
<p>For example:</p>
<pre class="programlisting">
Invalid free()
   at 0x4004FFDF: free (vg_clientmalloc.c:577)
   by 0x80484C7: main (tests/doublefree.c:10)
 Address 0x3807F7B4 is 0 bytes inside a block of size 177 free'd
   at 0x4004FFDF: free (vg_clientmalloc.c:577)
   by 0x80484C7: main (tests/doublefree.c:10)
</pre>
<p>Memcheck keeps track of the blocks allocated by your
program with malloc/new, so it can know exactly whether or not
the argument to free/delete is legitimate or not.  Here, this
test program has freed the same block twice.  As with the illegal
read/write errors, Memcheck attempts to make sense of the address
free'd.  If, as here, the address is one which has previously
been freed, you wil be told that -- making duplicate frees of the
same block easy to spot.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.rudefn"></a>3.3.4. When a block is freed with an inappropriate deallocation
function</h3></div></div>
<div></div>
</div>
<p>In the following example, a block allocated with
<tt class="computeroutput">new[]</tt> has wrongly been
deallocated with <tt class="computeroutput">free</tt>:</p>
<pre class="programlisting">
Mismatched free() / delete / delete []
   at 0x40043249: free (vg_clientfuncs.c:171)
   by 0x4102BB4E: QGArray::~QGArray(void) (tools/qgarray.cpp:149)
   by 0x4C261C41: PptDoc::~PptDoc(void) (include/qmemarray.h:60)
   by 0x4C261F0E: PptXml::~PptXml(void) (pptxml.cc:44)
 Address 0x4BB292A8 is 0 bytes inside a block of size 64 alloc'd
   at 0x4004318C: __builtin_vec_new (vg_clientfuncs.c:152)
   by 0x4C21BC15: KLaola::readSBStream(int) const (klaola.cc:314)
   by 0x4C21C155: KLaola::stream(KLaola::OLENode const *) (klaola.cc:416)
   by 0x4C21788F: OLEFilter::convert(QCString const &amp;) (olefilter.cc:272)
</pre>
<p>The following was told to me be the KDE 3 developers.  I
didn't know any of it myself.  They also implemented the check
itself.</p>
<p>In <tt class="literal">C++</tt> it's important to deallocate
memory in a way compatible with how it was allocated.  The deal
is:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>If allocated with
    <tt class="computeroutput">malloc</tt>,
    <tt class="computeroutput">calloc</tt>,
    <tt class="computeroutput">realloc</tt>,
    <tt class="computeroutput">valloc</tt> or
    <tt class="computeroutput">memalign</tt>, you must
    deallocate with <tt class="computeroutput">free</tt>.</p></li>
<li><p>If allocated with
    <tt class="computeroutput">new[]</tt>, you must deallocate
    with <tt class="computeroutput">delete[]</tt>.</p></li>
<li><p>If allocated with <tt class="computeroutput">new</tt>,
   you must deallocate with
   <tt class="computeroutput">delete</tt>.</p></li>
</ul></div>
<p>The worst thing is that on Linux apparently it doesn't
matter if you do muddle these up, and it all seems to work ok,
but the same program may then crash on a different platform,
Solaris for example.  So it's best to fix it properly.  According
to the KDE folks "it's amazing how many C++ programmers don't
know this".</p>
<p>Pascal Massimino adds the following clarification:
<tt class="computeroutput">delete[]</tt> must be called
associated with a <tt class="computeroutput">new[]</tt> because
the compiler stores the size of the array and the
pointer-to-member to the destructor of the array's content just
before the pointer actually returned.  This implies a
variable-sized overhead in what's returned by
<tt class="computeroutput">new</tt> or
<tt class="computeroutput">new[]</tt>.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.badperm"></a>3.3.5. Passing system call parameters with inadequate read/write
permissions</h3></div></div>
<div></div>
</div>
<p>Memcheck checks all parameters to system calls, i.e:
</p>
<div class="itemizedlist"><ul type="disc">
<li><p>It checks all the direct parameters
  themselves.</p></li>
<li><p>Also, if a system call needs to read from a buffer provided
  by your program, Memcheck checks that the entire buffer is addressible and
  has valid data, ie, it is readable.</p></li>
<li><p>Also, if the system call needs to write to a user-supplied
  buffer, Memcheck checks that the buffer is addressible.</p></li>
</ul></div>
<p>
</p>
<p>After the system call, Memcheck updates its tracked information to
precisely reflect any changes in memory permissions caused by the system call.
</p>
<p>Here's an example of two system calls with invalid parameters:</p>
<pre class="programlisting">
  #include &amp;lt;stdlib.h&gt;
  #include &amp;lt;unistd.h&gt;
  int main( void )
  {
    char* arr  = malloc(10);
    int*  arr2 = malloc(sizeof(int));
    write( 1 /* stdout */, arr, 10 );
    exit(arr2[0]);
  }
</pre>
<p>You get these complaints ...</p>
<pre class="programlisting">
  Syscall param write(buf) points to uninitialised byte(s)
     at 0x25A48723: __write_nocancel (in /lib/tls/libc-2.3.3.so)
     by 0x259AFAD3: __libc_start_main (in /lib/tls/libc-2.3.3.so)
     by 0x8048348: (within /auto/homes/njn25/grind/head4/a.out)
   Address 0x25AB8028 is 0 bytes inside a block of size 10 alloc'd
     at 0x259852B0: malloc (vg_replace_malloc.c:130)
     by 0x80483F1: main (a.c:5)

  Syscall param exit(error_code) contains uninitialised byte(s)
     at 0x25A21B44: __GI__exit (in /lib/tls/libc-2.3.3.so)
     by 0x8048426: main (a.c:8)
</pre>
<p>... because the program has (a) tried to write uninitialised junk from
the malloc'd block to the standard output, and (b) passed an uninitialised
value to <tt class="computeroutput">exit</tt>.  Note that the first error
refers to the memory pointed to by <tt class="computeroutput">buf</tt> (not
<tt class="computeroutput">buf</tt> itself), but the second error refers to
the argument <tt class="computeroutput">error_code</tt> itself.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.overlap"></a>3.3.6. Overlapping source and destination blocks</h3></div></div>
<div></div>
</div>
<p>The following C library functions copy some data from one
memory block to another (or something similar):
<tt class="computeroutput">memcpy()</tt>,
<tt class="computeroutput">strcpy()</tt>,
<tt class="computeroutput">strncpy()</tt>,
<tt class="computeroutput">strcat()</tt>,
<tt class="computeroutput">strncat()</tt>. 
The blocks pointed to by their
<tt class="computeroutput">src</tt> and
<tt class="computeroutput">dst</tt> pointers aren't allowed to
overlap.  Memcheck checks for this.</p>
<p>For example:</p>
<pre class="programlisting">
==27492== Source and destination overlap in memcpy(0xbffff294, 0xbffff280, 21)
==27492==    at 0x40026CDC: memcpy (mc_replace_strmem.c:71)
==27492==    by 0x804865A: main (overlap.c:40)
==27492== 
</pre>
<p>You don't want the two blocks to overlap because one of
them could get partially trashed by the copying.</p>
<p>You might think that Memcheck is being overly pedantic reporting
this in the case where <tt class="computeroutput">dst</tt> is less
than <tt class="computeroutput">src</tt>.  For example, the obvious way
to implement <tt class="computeroutput">memcpy()</tt> is by copying
from the first byte to the last.  However, the optimisation guides of
some architectures recommend copying from the last byte down to the first.
Also, some implementations of <tt class="computeroutput">memcpy()</tt>
zero <tt class="computeroutput">dst</tt> before copying, because zeroing
the destination's cache line(s) can improve performance.</p>
<p>The moral of the story is:  if you want to write truly portable code,
don't make any assumptions about the language implementation.</p>
</div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="mc-manual.flags.html">&lt;&lt; 3.2. Command-line flags specific to Memcheck</a> </td>
<td width="20%" align="center"><a accesskey="u" href="mc-manual.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="mc-manual.suppfiles.html">3.4. Writing suppressions files &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
