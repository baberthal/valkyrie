<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>1.4. Easy stuff which ought to be done</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="mc-tech-docs.html" title="1. The Design and Implementation of Valgrind">
<link rel="previous" href="mc-tech-docs.extensions.html" title="1.3. Extensions">
<link rel="next" href="cg-tech-docs.html" title="2. How Cachegrind works">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="mc-tech-docs.extensions.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="mc-tech-docs.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">1. The Design and Implementation of Valgrind</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="cg-tech-docs.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="mc-tech-docs.easystuff"></a>1.4. Easy stuff which ought to be done</h2></div></div>
<div></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-tech-docs.mmx"></a>1.4.1. MMX Instructions</h3></div></div>
<div></div>
</div>
<p>MMX insns should be supported, using the same trick as for
FPU insns.  If the MMX registers are not used to copy
uninitialised junk from one place to another in memory, this
means we don't have to actually simulate the internal MMX unit
state, so the FPU hack applies.  This should be fairly
easy.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-tech-docs.fixstabs"></a>1.4.2. Fix stabs-info reader</h3></div></div>
<div></div>
</div>
<p>The machinery in <tt class="filename">vg_symtab2.c</tt> which
reads "stabs" style debugging info is pretty weak.  It usually
correctly translates simulated program counter values into line
numbers and procedure names, but the file name is often
completely wrong.  I think the logic used to parse "stabs"
entries is weak.  It should be fixed.  The simplest solution,
IMO, is to copy either the logic or simply the code out of GNU
binutils which does this; since GDB can clearly get it right,
binutils (or GDB?) must have code to do this somewhere.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-tech-docs.x86instr"></a>1.4.3. BT/BTC/BTS/BTR</h3></div></div>
<div></div>
</div>
<p>These are x86 instructions which test, complement, set, or
reset, a single bit in a word.  At the moment they are both
incorrectly implemented and incorrectly instrumented.</p>
<p>The incorrect instrumentation is due to use of helper
functions.  This means we lose bit-level definedness tracking,
which could wind up giving spurious uninitialised-value use
errors.  The Right Thing to do is to invent a couple of new
UOpcodes, I think <tt class="computeroutput">GET_BIT</tt> and
<tt class="computeroutput">SET_BIT</tt>, which can be used to
implement all 4 x86 insns, get rid of the helpers, and give
bit-accurate instrumentation rules for the two new
UOpcodes.</p>
<p>I realised the other day that they are mis-implemented too.
The x86 insns take a bit-index and a register or memory location
to access.  For registers the bit index clearly can only be in
the range zero to register-width minus 1, and I assumed the same
applied to memory locations too.  But evidently not; for memory
locations the index can be arbitrary, and the processor will
index arbitrarily into memory as a result.  This too should be
fixed.  Sigh.  Presumably indexing outside the immediate word is
not actually used by any programs yet tested on Valgrind, for
otherwise they (presumably) would simply not work at all.  If you
plan to hack on this, first check the Intel docs to make sure my
understanding is really correct.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-tech-docs.prefetch"></a>1.4.4. Using PREFETCH Instructions</h3></div></div>
<div></div>
</div>
<p>Here's a small but potentially interesting project for
performance junkies.  Experiments with valgrind's code generator
and optimiser(s) suggest that reducing the number of instructions
executed in the translations and mem-check helpers gives
disappointingly small performance improvements.  Perhaps this is
because performance of Valgrindified code is limited by cache
misses.  After all, each read in the original program now gives
rise to at least three reads, one for the
<tt class="computeroutput">VG_(primary_map)</tt>, one of the
resulting secondary, and the original.  Not to mention, the
instrumented translations are 13 to 14 times larger than the
originals.  All in all one would expect the memory system to be
hammered to hell and then some.</p>
<p>So here's an idea.  An x86 insn involving a read from
memory, after instrumentation, will turn into ucode of the
following form:</p>
<pre class="programlisting">
... calculate effective addr, into ta and qa ...
  TESTVL qa             -- is the addr defined?
  LOADV (ta), qloaded   -- fetch V bits for the addr
  LOAD  (ta), tloaded   -- do the original load</pre>
<p>At the point where the
<tt class="computeroutput">LOADV</tt> is done, we know the
actual address (<tt class="computeroutput">ta</tt>) from which
the real <tt class="computeroutput">LOAD</tt> will be done.  We
also know that the <tt class="computeroutput">LOADV</tt> will
take around 20 x86 insns to do.  So it seems plausible that doing
a prefetch of <tt class="computeroutput">ta</tt> just before the
<tt class="computeroutput">LOADV</tt> might just avoid a miss at
the <tt class="computeroutput">LOAD</tt> point, and that might
be a significant performance win.</p>
<p>Prefetch insns are notoriously tempermental, more often
than not making things worse rather than better, so this would
require considerable fiddling around.  It's complicated because
Intels and AMDs have different prefetch insns with different
semantics, so that too needs to be taken into account.  As a
general rule, even placing the prefetches before the
<tt class="computeroutput">LOADV</tt> insn is too near the
<tt class="computeroutput">LOAD</tt>; the ideal distance is
apparently circa 200 CPU cycles.  So it might be worth having
another analysis/transformation pass which pushes prefetches as
far back as possible, hopefully immediately after the effective
address becomes available.</p>
<p>Doing too many prefetches is also bad because they soak up
bus bandwidth / cpu resources, so some cleverness in deciding
which loads to prefetch and which to not might be helpful.  One
can imagine not prefetching client-stack-relative
(<tt class="computeroutput">%EBP</tt> or
<tt class="computeroutput">%ESP</tt>) accesses, since the stack
in general tends to show good locality anyway.</p>
<p>There's quite a lot of experimentation to do here, but I
think it might make an interesting week's work for
someone.</p>
<p>As of 15-ish March 2002, I've started to experiment with
this, using the AMD
<tt class="computeroutput">prefetch/prefetchw</tt> insns.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-tech-docs.pranges"></a>1.4.5. User-defined Permission Ranges</h3></div></div>
<div></div>
</div>
<p>This is quite a large project -- perhaps a month's hacking
for a capable hacker to do a good job -- but it's potentially
very interesting.  The outcome would be that Valgrind could
detect a whole class of bugs which it currently cannot.</p>
<p>The presentation falls into two pieces.</p>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="mc-tech-docs.psetting"></a>1.4.5.1. Part 1: User-defined Address-range Permission Setting</h4></div></div>
<div></div>
</div>
<p>Valgrind intercepts the client's
<tt class="computeroutput">malloc</tt>,
<tt class="computeroutput">free</tt>, etc calls, watches system
calls, and watches the stack pointer move.  This is currently the
only way it knows about which addresses are valid and which not.
Sometimes the client program knows extra information about its
memory areas.  For example, the client could at some point know
that all elements of an array are out-of-date.  We would like to
be able to convey to Valgrind this information that the array is
now addressable-but-uninitialised, so that Valgrind can then warn
if elements are used before they get new values.</p>
<p>What I would like are some macros like this:</p>
<pre class="programlisting">
  VALGRIND_MAKE_NOACCESS(addr, len)
  VALGRIND_MAKE_WRITABLE(addr, len)
  VALGRIND_MAKE_READABLE(addr, len)</pre>
<p>and also, to check that memory is
addressible/initialised,</p>
<pre class="programlisting">
  VALGRIND_CHECK_ADDRESSIBLE(addr, len)
  VALGRIND_CHECK_INITIALISED(addr, len)</pre>
<p>I then include in my sources a header defining these
macros, rebuild my app, run under Valgrind, and get user-defined
checks.</p>
<p>Now here's a neat trick.  It's a nuisance to have to
re-link the app with some new library which implements the above
macros.  So the idea is to define the macros so that the
resulting executable is still completely stand-alone, and can be
run without Valgrind, in which case the macros do nothing, but
when run on Valgrind, the Right Thing happens.  How to do this?
The idea is for these macros to turn into a piece of inline
assembly code, which (1) has no effect when run on the real CPU,
(2) is easily spotted by Valgrind's JITter, and (3) no sane
person would ever write, which is important for avoiding false
matches in (2).  So here's a suggestion:</p>
<pre class="programlisting">
  VALGRIND_MAKE_NOACCESS(addr, len)</pre>
<p>becomes (roughly speaking)</p>
<pre class="programlisting">
  movl addr, %eax
  movl len,  %ebx
  movl $1,   %ecx   -- 1 describes the action; MAKE_WRITABLE might be
                    -- 2, etc
  rorl $13, %ecx
  rorl $19, %ecx
  rorl $11, %eax
  rorl $21, %eax</pre>
<p>The rotate sequences have no effect, and it's unlikely they
would appear for any other reason, but they define a unique
byte-sequence which the JITter can easily spot.  Using the
operand constraints section at the end of a gcc inline-assembly
statement, we can tell gcc that the assembly fragment kills
<tt class="computeroutput">%eax</tt>,
<tt class="computeroutput">%ebx</tt>,
<tt class="computeroutput">%ecx</tt> and the condition codes, so
this fragment is made harmless when not running on Valgrind, runs
quickly when not on Valgrind, and does not require any other
library support.</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="mc-tech-docs.prange-detect"></a>1.4.5.2. Part 2: Using it to detect Interference between Stack 
Variables</h4></div></div>
<div></div>
</div>
<p>Currently Valgrind cannot detect errors of the following
form:</p>
<pre class="programlisting">
void fooble ( void )
{
  int a[10];
  int b[10];
  a[10] = 99;
}</pre>
<p>Now imagine rewriting this as</p>
<pre class="programlisting">
void fooble ( void )
{
  int spacer0;
  int a[10];
  int spacer1;
  int b[10];
  int spacer2;
  VALGRIND_MAKE_NOACCESS(&amp;spacer0, sizeof(int));
  VALGRIND_MAKE_NOACCESS(&amp;spacer1, sizeof(int));
  VALGRIND_MAKE_NOACCESS(&amp;spacer2, sizeof(int));
  a[10] = 99;
}</pre>
<p>Now the invalid write is certain to hit
<tt class="computeroutput">spacer0</tt> or
<tt class="computeroutput">spacer1</tt>, so Valgrind will spot
the error.</p>
<p>There are two complications.</p>
<div class="orderedlist"><ol type="1">
<li><p>The first is that we don't want to annotate sources by
    hand, so the Right Thing to do is to write a C/C++ parser,
    annotator, prettyprinter which does this automatically, and
    run it on post-CPP'd C/C++ source.  See
    http://www.cacheprof.org for an example of a system which
    transparently inserts another phase into the gcc/g++
    compilation route.  The parser/prettyprinter is probably not
    as hard as it sounds; I would write it in Haskell, a powerful
    functional language well suited to doing symbolic
    computation, with which I am intimately familar.  There is
    already a C parser written in Haskell by someone in the
    Haskell community, and that would probably be a good starting
    point.</p></li>
<li>
<p>The second complication is how to get rid of these
    <tt class="computeroutput">NOACCESS</tt> records inside
    Valgrind when the instrumented function exits; after all,
    these refer to stack addresses and will make no sense
    whatever when some other function happens to re-use the same
    stack address range, probably shortly afterwards.  I think I
    would be inclined to define a special stack-specific
    macro:</p>
<pre class="programlisting">
  VALGRIND_MAKE_NOACCESS_STACK(addr, len)</pre>
<p>which causes Valgrind to record the client's
    <tt class="computeroutput">%ESP</tt> at the time it is
    executed.  Valgrind will then watch for changes in
    <tt class="computeroutput">%ESP</tt> and discard such
    records as soon as the protected area is uncovered by an
    increase in <tt class="computeroutput">%ESP</tt>.  I
    hesitate with this scheme only because it is potentially
    expensive, if there are hundreds of such records, and
    considering that changes in
    <tt class="computeroutput">%ESP</tt> already require
    expensive messing with stack access permissions.</p>
</li>
</ol></div>
<p>This is probably easier and more robust than for the
instrumenter program to try and spot all exit points for the
procedure and place suitable deallocation annotations there.
Plus C++ procedures can bomb out at any point if they get an
exception, so spotting return points at the source level just
won't work at all.</p>
<p>Although some work, it's all eminently doable, and it would
make Valgrind into an even-more-useful tool.</p>
</div>
</div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="mc-tech-docs.extensions.html">&lt;&lt; 1.3. Extensions</a> </td>
<td width="20%" align="center"><a accesskey="u" href="mc-tech-docs.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="cg-tech-docs.html">2. How Cachegrind works &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
