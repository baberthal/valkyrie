<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>5.2. Profiling programs</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="cg-manual.html" title="5. Cachegrind: a cache profiler">
<link rel="previous" href="cg-manual.html" title="5. Cachegrind: a cache profiler">
<link rel="next" href="cg-manual.annopts.html" title="5.3. cg_annotate options">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="cg-manual.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="cg-manual.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">5. Cachegrind: a cache profiler</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="cg-manual.annopts.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="cg-manual.profile"></a>5.2. Profiling programs</h2></div></div>
<div></div>
</div>
<p>To gather cache profiling information about the program
<tt class="computeroutput">ls -l</tt>, invoke Cachegrind like
this:</p>
<pre class="programlisting">
valgrind --tool=cachegrind ls -l</pre>
<p>The program will execute (slowly).  Upon completion,
summary statistics that look like this will be printed:</p>
<pre class="programlisting">
==31751== I   refs:      27,742,716
==31751== I1  misses:           276
==31751== L2  misses:           275
==31751== I1  miss rate:        0.0%
==31751== L2i miss rate:        0.0%
==31751== 
==31751== D   refs:      15,430,290  (10,955,517 rd + 4,474,773 wr)
==31751== D1  misses:        41,185  (    21,905 rd +    19,280 wr)
==31751== L2  misses:        23,085  (     3,987 rd +    19,098 wr)
==31751== D1  miss rate:        0.2% (       0.1%   +       0.4%)
==31751== L2d miss rate:        0.1% (       0.0%   +       0.4%)
==31751== 
==31751== L2 misses:         23,360  (     4,262 rd +    19,098 wr)
==31751== L2 miss rate:         0.0% (       0.0%   +       0.4%)</pre>
<p>Cache accesses for instruction fetches are summarised
first, giving the number of fetches made (this is the number of
instructions executed, which can be useful to know in its own
right), the number of I1 misses, and the number of L2 instruction
(<tt class="computeroutput">L2i</tt>) misses.</p>
<p>Cache accesses for data follow. The information is similar
to that of the instruction fetches, except that the values are
also shown split between reads and writes (note each row's
<tt class="computeroutput">rd</tt> and
<tt class="computeroutput">wr</tt> values add up to the row's
total).</p>
<p>Combined instruction and data figures for the L2 cache
follow that.</p>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="cg-manual.outputfile"></a>5.2.1. Output file</h3></div></div>
<div></div>
</div>
<p>As well as printing summary information, Cachegrind also
writes line-by-line cache profiling information to a file named
<tt class="computeroutput">cachegrind.out.pid</tt>.  This file
is human-readable, but is best interpreted by the accompanying
program <tt class="computeroutput">cg_annotate</tt>, described
in the next section.</p>
<p>Things to note about the
<tt class="computeroutput">cachegrind.out.pid</tt>
file:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>It is written every time Cachegrind is run, and will
    overwrite any existing
    <tt class="computeroutput">cachegrind.out.pid</tt>
    in the current directory (but that won't happen very often
    because it takes some time for process ids to be
    recycled).</p></li>
<li><p>It can be huge: <tt class="computeroutput">ls -l</tt>
    generates a file of about 350KB.  Browsing a few files and
    web pages with a Konqueror built with full debugging
    information generates a file of around 15 MB.</p></li>
</ul></div>
<p>Note that older versions of Cachegrind used a log file
named <tt class="computeroutput">cachegrind.out</tt> (i.e. no
<tt class="computeroutput">.pid</tt> suffix).  The suffix serves
two purposes.  Firstly, it means you don't have to rename old log
files that you don't want to overwrite.  Secondly, and more
importantly, it allows correct profiling with the
<tt class="computeroutput">--trace-children=yes</tt> option of
programs that spawn child processes.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="cg-manual.cgopts"></a>5.2.2. Cachegrind options</h3></div></div>
<div></div>
</div>
<p>Cache-simulation specific options are:</p>
<pre class="screen">
--I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line_size&gt;
--D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line_size&gt;
--L2=&lt;size&gt;,&lt;associativity&gt;,&lt;line_size&gt;

[default: uses CPUID for automagic cache configuration]</pre>
<p>Manually specifies the I1/D1/L2 cache configuration, where
<tt class="computeroutput">size</tt> and
<tt class="computeroutput">line_size</tt> are measured in bytes.
The three items must be comma-separated, but with no spaces,
eg:</p>
<pre class="programlisting">
valgrind --tool=cachegrind --I1=65535,2,64</pre>
<p>You can specify one, two or three of the I1/D1/L2 caches.
Any level not manually specified will be simulated using the
configuration found in the normal way (via the CPUID instruction,
or failing that, via defaults).</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="cg-manual.annotate"></a>5.2.3. Annotating C/C++ programs</h3></div></div>
<div></div>
</div>
<p>Before using <tt class="computeroutput">cg_annotate</tt>,
it is worth widening your window to be at least 120-characters
wide if possible, as the output lines can be quite long.</p>
<p>To get a function-by-function summary, run
<tt class="computeroutput">cg_annotate --pid</tt> in a directory
containing a <tt class="computeroutput">cachegrind.out.pid</tt>
file.  The <span class="emphasis"><em>--pid</em></span> is required so that
<tt class="computeroutput">cg_annotate</tt> knows which log file
to use when several are present.</p>
<p>The output looks like this:</p>
<pre class="programlisting">
--------------------------------------------------------------------------------
I1 cache:              65536 B, 64 B, 2-way associative
D1 cache:              65536 B, 64 B, 2-way associative
L2 cache:              262144 B, 64 B, 8-way associative
Command:               concord vg_to_ucode.c
Events recorded:       Ir I1mr I2mr Dr D1mr D2mr Dw D1mw D2mw
Events shown:          Ir I1mr I2mr Dr D1mr D2mr Dw D1mw D2mw
Event sort order:      Ir I1mr I2mr Dr D1mr D2mr Dw D1mw D2mw
Threshold:             99%
Chosen for annotation:
Auto-annotation:       on

--------------------------------------------------------------------------------
Ir         I1mr I2mr Dr         D1mr   D2mr  Dw        D1mw   D2mw
--------------------------------------------------------------------------------
27,742,716  276  275 10,955,517 21,905 3,987 4,474,773 19,280 19,098  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir        I1mr I2mr Dr        D1mr  D2mr  Dw        D1mw   D2mw    file:function
--------------------------------------------------------------------------------
8,821,482    5    5 2,242,702 1,621    73 1,794,230      0      0  getc.c:_IO_getc
5,222,023    4    4 2,276,334    16    12   875,959      1      1  concord.c:get_word
2,649,248    2    2 1,344,810 7,326 1,385         .      .      .  vg_main.c:strcmp
2,521,927    2    2   591,215     0     0   179,398      0      0  concord.c:hash
2,242,740    2    2 1,046,612   568    22   448,548      0      0  ctype.c:tolower
1,496,937    4    4   630,874 9,000 1,400   279,388      0      0  concord.c:insert
  897,991   51   51   897,831    95    30        62      1      1  ???:???
  598,068    1    1   299,034     0     0   149,517      0      0  ../sysdeps/generic/lockfile.c:__flockfile
  598,068    0    0   299,034     0     0   149,517      0      0  ../sysdeps/generic/lockfile.c:__funlockfile
  598,024    4    4   213,580    35    16   149,506      0      0  vg_clientmalloc.c:malloc
  446,587    1    1   215,973 2,167   430   129,948 14,057 13,957  concord.c:add_existing
  341,760    2    2   128,160     0     0   128,160      0      0  vg_clientmalloc.c:vg_trap_here_WRAPPER
  320,782    4    4   150,711   276     0    56,027     53     53  concord.c:init_hash_table
  298,998    1    1   106,785     0     0    64,071      1      1  concord.c:create
  149,518    0    0   149,516     0     0         1      0      0  ???:tolower@@GLIBC_2.0
  149,518    0    0   149,516     0     0         1      0      0  ???:fgetc@@GLIBC_2.0
   95,983    4    4    38,031     0     0    34,409  3,152  3,150  concord.c:new_word_node
   85,440    0    0    42,720     0     0    21,360      0      0  vg_clientmalloc.c:vg_bogus_epilogue</pre>
<p>First up is a summary of the annotation options:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>I1 cache, D1 cache, L2 cache: cache configuration.  So
    you know the configuration with which these results were
    obtained.</p></li>
<li><p>Command: the command line invocation of the program
      under examination.</p></li>
<li>
<p>Events recorded: event abbreviations are:</p>
<div class="itemizedlist"><ul type="circle">
<li><p><tt class="computeroutput">Ir </tt>: I cache reads
       (ie. instructions executed)</p></li>
<li><p><tt class="computeroutput">I1mr</tt>: I1 cache read
       misses</p></li>
<li><p><tt class="computeroutput">I2mr</tt>: L2 cache
       instruction read misses</p></li>
<li><p><tt class="computeroutput">Dr </tt>: D cache reads
       (ie. memory reads)</p></li>
<li><p><tt class="computeroutput">D1mr</tt>: D1 cache read
       misses</p></li>
<li><p><tt class="computeroutput">D2mr</tt>: L2 cache data
       read misses</p></li>
<li><p><tt class="computeroutput">Dw </tt>: D cache writes
       (ie. memory writes)</p></li>
<li><p><tt class="computeroutput">D1mw</tt>: D1 cache write
       misses</p></li>
<li><p><tt class="computeroutput">D2mw</tt>: L2 cache data
       write misses</p></li>
</ul></div>
<p>Note that D1 total accesses is given by
   <tt class="computeroutput">D1mr</tt> +
   <tt class="computeroutput">D1mw</tt>, and that L2 total
   accesses is given by <tt class="computeroutput">I2mr</tt> +
   <tt class="computeroutput">D2mr</tt> +
   <tt class="computeroutput">D2mw</tt>.</p>
</li>
<li><p>Events shown: the events shown (a subset of events
   gathered).  This can be adjusted with the
   <tt class="computeroutput">--show</tt> option.</p></li>
<li>
<p>Event sort order: the sort order in which functions are
    shown.  For example, in this case the functions are sorted
    from highest <tt class="computeroutput">Ir</tt> counts to
    lowest.  If two functions have identical
    <tt class="computeroutput">Ir</tt> counts, they will then be
    sorted by <tt class="computeroutput">I1mr</tt> counts, and
    so on.  This order can be adjusted with the
    <tt class="computeroutput">--sort</tt> option.</p>
<p>Note that this dictates the order the functions appear.
    It is <span><b class="command">not</b></span> the order in which the columns
    appear; that is dictated by the "events shown" line (and can
    be changed with the <tt class="computeroutput">--show</tt>
    option).</p>
</li>
<li><p>Threshold: <tt class="computeroutput">cg_annotate</tt>
    by default omits functions that cause very low numbers of
    misses to avoid drowning you in information.  In this case,
    cg_annotate shows summaries the functions that account for
    99% of the <tt class="computeroutput">Ir</tt> counts;
    <tt class="computeroutput">Ir</tt> is chosen as the
    threshold event since it is the primary sort event.  The
    threshold can be adjusted with the
    <tt class="computeroutput">--threshold</tt>
    option.</p></li>
<li><p>Chosen for annotation: names of files specified
    manually for annotation; in this case none.</p></li>
<li><p>Auto-annotation: whether auto-annotation was requested
    via the <tt class="computeroutput">--auto=yes</tt>
    option. In this case no.</p></li>
</ul></div>
<p>Then follows summary statistics for the whole
program. These are similar to the summary provided when running
<tt class="computeroutput">valgrind
--tool=cachegrind</tt>.</p>
<p>Then follows function-by-function statistics. Each function
is identified by a
<tt class="computeroutput">file_name:function_name</tt> pair. If
a column contains only a dot it means the function never performs
that event (eg. the third row shows that
<tt class="computeroutput">strcmp()</tt> contains no
instructions that write to memory). The name
<tt class="computeroutput">???</tt> is used if the the file name
and/or function name could not be determined from debugging
information. If most of the entries have the form
<tt class="computeroutput">???:???</tt> the program probably
wasn't compiled with <tt class="computeroutput">-g</tt>.  If any
code was invalidated (either due to self-modifying code or
unloading of shared objects) its counts are aggregated into a
single cost centre written as
<tt class="computeroutput">(discarded):(discarded)</tt>.</p>
<p>It is worth noting that functions will come from three
types of source files:</p>
<div class="orderedlist"><ol type="1">
<li><p>From the profiled program
    (<tt class="filename">concord.c</tt> in this example).</p></li>
<li><p>From libraries (eg. <tt class="filename">getc.c</tt>)</p></li>
<li><p>From Valgrind's implementation of some libc functions
    (eg. <tt class="computeroutput">vg_clientmalloc.c:malloc</tt>).
    These are recognisable because the filename begins with
    <tt class="computeroutput">vg_</tt>, and is probably one of
    <tt class="filename">vg_main.c</tt>,
    <tt class="filename">vg_clientmalloc.c</tt> or
    <tt class="filename">vg_mylibc.c</tt>.</p></li>
</ol></div>
<p>There are two ways to annotate source files -- by choosing
them manually, or with the
<tt class="computeroutput">--auto=yes</tt> option. To do it
manually, just specify the filenames as arguments to
<tt class="computeroutput">cg_annotate</tt>. For example, the
output from running <tt class="filename">cg_annotate concord.c</tt>
for our example produces the same output as above followed by an
annotated version of <tt class="filename">concord.c</tt>, a section of
which looks like:</p>
<pre class="programlisting">
--------------------------------------------------------------------------------
-- User-annotated source: concord.c
--------------------------------------------------------------------------------
Ir        I1mr I2mr Dr      D1mr  D2mr  Dw      D1mw   D2mw

[snip]

        .    .    .       .     .     .       .      .      .  void init_hash_table(char *file_name, Word_Node *table[])
        3    1    1       .     .     .       1      0      0  {
        .    .    .       .     .     .       .      .      .      FILE *file_ptr;
        .    .    .       .     .     .       .      .      .      Word_Info *data;
        1    0    0       .     .     .       1      1      1      int line = 1, i;
        .    .    .       .     .     .       .      .      .
        5    0    0       .     .     .       3      0      0      data = (Word_Info *) create(sizeof(Word_Info));
        .    .    .       .     .     .       .      .      .
    4,991    0    0   1,995     0     0     998      0      0      for (i = 0; i &lt; TABLE_SIZE; i++)
    3,988    1    1   1,994     0     0     997     53     52          table[i] = NULL;
        .    .    .       .     .     .       .      .      .
        .    .    .       .     .     .       .      .      .      /* Open file, check it. */
        6    0    0       1     0     0       4      0      0      file_ptr = fopen(file_name, "r");
        2    0    0       1     0     0       .      .      .      if (!(file_ptr)) {
        .    .    .       .     .     .       .      .      .          fprintf(stderr, "Couldn't open '%s'.\n", file_name);
        1    1    1       .     .     .       .      .      .          exit(EXIT_FAILURE);
        .    .    .       .     .     .       .      .      .      }
        .    .    .       .     .     .       .      .      .
  165,062    1    1  73,360     0     0  91,700      0      0      while ((line = get_word(data, line, file_ptr)) != EOF)
  146,712    0    0  73,356     0     0  73,356      0      0          insert(data-&gt;;word, data-&gt;line, table);
        .    .    .       .     .     .       .      .      .
        4    0    0       1     0     0       2      0      0      free(data);
        4    0    0       1     0     0       2      0      0      fclose(file_ptr);
        3    0    0       2     0     0       .      .      .  }</pre>
<p>(Although column widths are automatically minimised, a wide
terminal is clearly useful.)</p>
<p>Each source file is clearly marked
(<tt class="computeroutput">User-annotated source</tt>) as
having been chosen manually for annotation.  If the file was
found in one of the directories specified with the
<tt class="computeroutput">-I / --include</tt> option, the directory
and file are both given.</p>
<p>Each line is annotated with its event counts.  Events not
applicable for a line are represented by a `.'; this is useful
for distinguishing between an event which cannot happen, and one
which can but did not.</p>
<p>Sometimes only a small section of a source file is
executed.  To minimise uninteresting output, Valgrind only shows
annotated lines and lines within a small distance of annotated
lines.  Gaps are marked with the line numbers so you know which
part of a file the shown code comes from, eg:</p>
<pre class="programlisting">
(figures and code for line 704)
-- line 704 ----------------------------------------
-- line 878 ----------------------------------------
(figures and code for line 878)</pre>
<p>The amount of context to show around annotated lines is
controlled by the <tt class="computeroutput">--context</tt>
option.</p>
<p>To get automatic annotation, run
<tt class="computeroutput">cg_annotate --auto=yes</tt>.
cg_annotate will automatically annotate every source file it can
find that is mentioned in the function-by-function summary.
Therefore, the files chosen for auto-annotation are affected by
the <tt class="computeroutput">--sort</tt> and
<tt class="computeroutput">--threshold</tt> options.  Each
source file is clearly marked (<tt class="computeroutput">Auto-annotated
source</tt>) as being chosen automatically.  Any
files that could not be found are mentioned at the end of the
output, eg:</p>
<pre class="programlisting">
------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
------------------------------------------------------------------
  getc.c
  ctype.c
  ../sysdeps/generic/lockfile.c</pre>
<p>This is quite common for library files, since libraries are
usually compiled with debugging information, but the source files
are often not present on a system.  If a file is chosen for
annotation <span><b class="command">both</b></span> manually and automatically, it
is marked as <tt class="computeroutput">User-annotated
source</tt>. Use the <tt class="computeroutput">-I /
--include</tt> option to tell Valgrind where to look
for source files if the filenames found from the debugging
information aren't specific enough.</p>
<p>Beware that cg_annotate can take some time to digest large
<tt class="computeroutput">cachegrind.out.pid</tt> files,
e.g. 30 seconds or more.  Also beware that auto-annotation can
produce a lot of output if your program is large!</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="cg-manual.assembler"></a>5.2.4. Annotating assembler programs</h3></div></div>
<div></div>
</div>
<p>Valgrind can annotate assembler programs too, or annotate
the assembler generated for your C program.  Sometimes this is
useful for understanding what is really happening when an
interesting line of C code is translated into multiple
instructions.</p>
<p>To do this, you just need to assemble your
<tt class="computeroutput">.s</tt> files with assembler-level
debug information.  gcc doesn't do this, but you can use the GNU
assembler with the <tt class="computeroutput">--gstabs</tt>
option to generate object files with this information, eg:</p>
<pre class="programlisting">
as --gstabs foo.s</pre>
<p>You can then profile and annotate source files in the same
way as for C/C++ programs.</p>
</div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="cg-manual.html">&lt;&lt; 5. Cachegrind: a cache profiler</a> </td>
<td width="20%" align="center"><a accesskey="u" href="cg-manual.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="cg-manual.annopts.html">5.3. cg_annotate options &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
