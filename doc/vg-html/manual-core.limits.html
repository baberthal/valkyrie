<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>2.12. Limitations</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="manual-core.html" title="2. Using and understanding the Valgrind core">
<link rel="previous" href="manual-core.problems.html" title="2.11. If You Have Problems">
<link rel="next" href="manual-core.howworks.html" title="2.13. How It Works -- A Rough Overview">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="manual-core.problems.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="manual-core.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">2. Using and understanding the Valgrind core</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="manual-core.howworks.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="manual-core.limits"></a>2.12. Limitations</h2></div></div>
<div></div>
</div>
<p>The following list of limitations seems depressingly long.
However, most programs actually work fine.</p>
<p>Valgrind will run x86/Linux ELF dynamically linked
binaries, on a kernel 2.4.X or 2.6.X system, subject to
the following constraints:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>On x86 and AMD64, there is no support for 3DNow! instructions.  If
   the translator encounters these, Valgrind will generate a SIGILL when the
   instruction is executed.</p></li>
<li><p>Atomic instruction sequences are not supported, which will affect
   any use of synchronization objects being shared between processes.  They
   will appear to work, but fail sporadically.</p></li>
<li><p>If your program does its own memory management, rather
   than using malloc/new/free/delete, it should still work, but
   Valgrind's error checking won't be so effective.  If you
   describe your program's memory management scheme using "client
   requests" (Section 3.7 of this manual), Memcheck can do
   better.  Nevertheless, using malloc/new and free/delete is
   still the best approach.</p></li>
<li><p>Valgrind's signal simulation is not as robust as it
   could be.  Basic POSIX-compliant sigaction and sigprocmask
   functionality is supplied, but it's conceivable that things
   could go badly awry if you do weird things with signals.
   Workaround: don't.  Programs that do non-POSIX signal tricks
   are in any case inherently unportable, so should be avoided if
   possible.</p></li>
<li><p>Machine instructions, and system calls, have been
   implemented on demand.  So it's possible, although unlikely,
   that a program will fall over with a message to that effect.
   If this happens, please report ALL the details printed out, so
   we can try and implement the missing feature.</p></li>
<li><p>Memory consumption of your program is majorly increased
   whilst running under Valgrind.  This is due to the large
   amount of administrative information maintained behind the
   scenes.  Another cause is that Valgrind dynamically translates
   the original executable.  Translated, instrumented code is
   14-16 times larger than the original (!) so you can easily end
   up with 30+ MB of translations when running (eg) a web
   browser.</p></li>
<li><p>Valgrind can handle dynamically-generated code just
   fine.  If you regenerate code over the top of old code
   (ie. at the same memory addresses), if the code is on the stack Valgrind
   will realise the code has changed, and work correctly.  This is necessary
   to handle the trampolines GCC uses to implemented nested functions.
   If you regenerate code somewhere other than the stack, you will need to
   use the <tt class="computeroutput">--smc-check=all</tt> flag, and
   Valgrind will run more slowly than normal.</p></li>
<li>
<p>As of version 3.0.0, Valgrind has the following limitations
   in its implementation of floating point relative to the IEEE754 standard.
   </p>
<p>Precision: There is no support for 80 bit arithmetic.
   Internally, Valgrind represents all FP numbers in 64 bits, and so
   there may be some differences in results.  Whether or not this is
   critical remains to be seen.  Note, the x86/amd64 fldt/fstpt
   instructions (read/write 80-bit numbers) are correctly simulated,
   using conversions to/from 64 bits, so that in-memory images of
   80-bit numbers look correct if anyone wants to see.</p>
<p>The impression observed from many FP regression tests is that
   the accuracy differences aren't significant.  Generally speaking, if
   a program relies on 80-bit precision, there may be difficulties
   porting it to non x86/amd64 platforms which only support 64-bit FP
   precision.  Even on x86/amd64, the program may get different results
   depending on whether it is compiled to use SSE2 instructions
   (64-bits only), or x87 instructions (80-bit).  The net effect is to
   make FP programs behave as if they had been run on a machine with
   64-bit IEEE floats, for example PowerPC.  On amd64 FP arithmetic is
   done by default on SSE2, so amd64 looks more like PowerPC than x86
   from an FP perspective, and there are far fewer noticable accuracy
   differences than with x86.</p>
<p>Rounding: Valgrind does observe the 4 IEEE-mandated rounding
   modes (to nearest, to +infinity, to -infinity, to zero) for the
   following conversions: float to integer, integer to float where
   there is a possibility of loss of precision, and float-to-float
   rounding.  For all other FP operations, only the IEEE default mode
   (round to nearest) is supported.</p>
<p>Numeric exceptions in FP code: IEEE754 defines five types of
   numeric exception that can happen: invalid operation (sqrt of
   negative number, etc), division by zero, overflow, underflow,
   inexact (loss of precision).</p>
<p>For each exception, two courses of action are defined by 754:
   either (1) a user-defined exception handler may be called, or (2) a
   default action is defined, which "fixes things up" and allows the
   computation to proceed without throwing an exception.</p>
<p>Currently Valgrind only supports the default fixup actions.
   Again, feedback on the importance of exception support would be
   appreciated.</p>
<p>When Valgrind detects that the program is trying to exceed any
   of these limitations (setting exception handlers, rounding mode, or
   precision control), it can print a message giving a traceback of
   where this has happened, and continue execution.  This behaviour
   used to be the default, but the messages are annoying and so showing
   them is now optional.  Use
   <tt class="computeroutput">--show-emwarns=yes</tt> to see
   them.</p>
<p>The above limitations define precisely the IEEE754 'default'
   behaviour: default fixup on all exceptions, round-to-nearest
   operations, and 64-bit precision.</p>
</li>
<li>
<p>As of version 3.0.0, Valgrind has the following limitations
   in its implementation of x86/AMD64 SSE2 FP arithmetic.</p>
<p>Essentially the same: no exceptions, and limited observance
   of rounding mode.  Also, SSE2 has control bits which make it treat
   denormalised numbers as zero (DAZ) and a related action, flush
   denormals to zero (FTZ).  Both of these cause SSE2 arithmetic to be
   less accurate than IEEE requires.  Valgrind detects, ignores, and
   can warn about, attempts to enable either mode.</p>
</li>
</ul></div>
<p>Programs which are known not to work are:</p>
<div class="itemizedlist"><ul type="disc"><li><p>emacs starts up but immediately concludes it is out of
   memory and aborts.  Emacs has it's own memory-management
   scheme, but I don't understand why this should interact so
   badly with Valgrind.  Emacs works fine if you build it to use
   the standard malloc/free routines.</p></li></ul></div>
<p>Known platform-specific limitations, as of release 2.4.0:</p>
<div class="itemizedlist"><ul type="disc"><li><p>(none)</p></li></ul></div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="manual-core.problems.html">&lt;&lt; 2.11. If You Have Problems</a> </td>
<td width="20%" align="center"><a accesskey="u" href="manual-core.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="manual-core.howworks.html">2.13. How It Works -- A Rough Overview &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
