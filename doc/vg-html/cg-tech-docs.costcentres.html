<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>2.2. Cost centres</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="cg-tech-docs.html" title="2. How Cachegrind works">
<link rel="previous" href="cg-tech-docs.html" title="2. How Cachegrind works">
<link rel="next" href="cg-tech-docs.ccstore.html" title="2.3. Storing cost-centres">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="cg-tech-docs.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="cg-tech-docs.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">2. How Cachegrind works</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="cg-tech-docs.ccstore.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="cg-tech-docs.costcentres"></a>2.2. Cost centres</h2></div></div>
<div></div>
</div>
<p>Valgrind gathers cache profiling about every instruction
executed, individually.  Each instruction has a <span><b class="command">cost
centre</b></span> associated with it.  There are two kinds of cost
centre: one for instructions that don't reference memory
(<tt class="computeroutput">iCC</tt>), and one for instructions
that do (<tt class="computeroutput">idCC</tt>):</p>
<pre class="programlisting">
typedef struct _CC {
  ULong a;
  ULong m1;
  ULong m2;
} CC;

typedef struct _iCC {
  /* word 1 */
  UChar tag;
  UChar instr_size;

  /* words 2+ */
  Addr instr_addr;
  CC I;
} iCC;
   
typedef struct _idCC {
  /* word 1 */
  UChar tag;
  UChar instr_size;
  UChar data_size;

  /* words 2+ */
  Addr instr_addr;
  CC I; 
  CC D; 
} idCC; </pre>
<p>Each <tt class="computeroutput">CC</tt> has three fields
<tt class="computeroutput">a</tt>,
<tt class="computeroutput">m1</tt>,
<tt class="computeroutput">m2</tt> for recording references,
level 1 misses and level 2 misses.  Each of these is a 64-bit
<tt class="computeroutput">ULong</tt> -- the numbers can get
very large, ie. greater than 4.2 billion allowed by a 32-bit
unsigned int.</p>
<p>A <tt class="computeroutput">iCC</tt> has one
<tt class="computeroutput">CC</tt> for instruction cache
accesses.  A <tt class="computeroutput">idCC</tt> has two, one
for instruction cache accesses, and one for data cache
accesses.</p>
<p>The <tt class="computeroutput">iCC</tt> and
<tt class="computeroutput">dCC</tt> structs also store
unchanging information about the instruction:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>An instruction-type identification tag (explained
    below)</p></li>
<li><p>Instruction size</p></li>
<li><p>Data reference size
    (<tt class="computeroutput">idCC</tt> only)</p></li>
<li><p>Instruction address</p></li>
</ul></div>
<p>Note that data address is not one of the fields for
<tt class="computeroutput">idCC</tt>.  This is because for many
memory-referencing instructions the data address can change each
time it's executed (eg. if it uses register-offset addressing).
We have to give this item to the cache simulation in a different
way (see Instrumentation section below). Some memory-referencing
instructions do always reference the same address, but we don't
try to treat them specialy in order to keep things simple.</p>
<p>Also note that there is only room for recording info about
one data cache access in an
<tt class="computeroutput">idCC</tt>.  So what about
instructions that do a read then a write, such as:</p>
<pre class="programlisting">
inc %(esi)</pre>
<p>In a write-allocate cache, as simulated by Valgrind, the
write cannot miss, since it immediately follows the read which
will drag the block into the cache if it's not already there.  So
the write access isn't really interesting, and Valgrind doesn't
record it.  This means that Valgrind doesn't measure memory
references, but rather memory references that could miss in the
cache.  This behaviour is the same as that used by the AMD Athlon
hardware counters.  It also has the benefit of simplifying the
implementation -- instructions that read and write memory can be
treated like instructions that read memory.</p>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="cg-tech-docs.html">&lt;&lt; 2. How Cachegrind works</a> </td>
<td width="20%" align="center"><a accesskey="u" href="cg-tech-docs.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="cg-tech-docs.ccstore.html">2.3. Storing cost-centres &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
