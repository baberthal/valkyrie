<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>2.8. Support for Threads</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="manual-core.html" title="2. Using and understanding the Valgrind core">
<link rel="previous" href="manual-core.clientreq.html" title="2.7. The Client Request mechanism">
<link rel="next" href="manual-core.signals.html" title="2.9. Handling of Signals">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="manual-core.clientreq.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="manual-core.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">2. Using and understanding the Valgrind core</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="manual-core.signals.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="manual-core.pthreads"></a>2.8. Support for Threads</h2></div></div>
<div></div>
</div>
<p>Valgrind supports programs which use POSIX pthreads.
Getting this to work was technically challenging but it all works
well enough for significant threaded applications to work.</p>
<p>It works as follows: threaded apps are (dynamically) linked
against <tt class="literal">libpthread.so</tt>.  Usually this is the
one installed with your Linux distribution.  Valgrind, however,
supplies its own <tt class="literal">libpthread.so</tt> and
automatically connects your program to it instead.</p>
<p>The fake <tt class="literal">libpthread.so</tt> and Valgrind
cooperate to implement a user-space pthreads package.  This
approach avoids the horrible implementation problems of
implementing a truly multiprocessor version of Valgrind, but it
does mean that threaded apps run only on one CPU, even if you
have a multiprocessor machine.</p>
<p>Your program will use the native
<tt class="computeroutput">libpthread</tt>, but not all of its facilities
will work.  In particular, process-shared synchronization WILL NOT
WORK.  They rely on special atomic instruction sequences which
Valgrind does not emulate in a way which works between processes.
Unfortunately there's no way for Valgrind to warn when this is happening,
and such calls will mostly work; it's only when there's a race will it fail.
</p>
<p>Valgrind also supports direct use of the
<tt class="computeroutput">clone()</tt> system call,
<tt class="computeroutput">futex()</tt> and so on.
<tt class="computeroutput">clone()</tt> is supported where either
everything is shared (a thread) or nothing is shared (fork-like); partial
sharing will fail.  Again, any use of atomic instruction sequences in shared
memory between processes will not work.
</p>
<p>Valgrind schedules your threads in a round-robin fashion,
with all threads having equal priority.  It switches threads
every 50000 basic blocks (typically around 300000 x86
instructions), which means you'll get a much finer interleaving
of thread executions than when run natively.  This in itself may
cause your program to behave differently if you have some kind of
concurrency, critical race, locking, or similar, bugs.</p>
<p>As of the Valgrind-1.0 release, the state of pthread
support was as follows:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Mutexes, condition variables, thread-specific data,
   <tt class="computeroutput">pthread_once</tt>, reader-writer
   locks, semaphores, cleanup stacks, cancellation and thread
   detaching currently work.  Various attribute-like calls are
   handled but ignored; you get a warning message.</p></li>
<li><p>Currently the following syscalls are thread-safe
   (nonblocking): <tt class="literal">write</tt>,
   <tt class="literal">read</tt>, <tt class="literal">nanosleep</tt>,
   <tt class="literal">sleep</tt>, <tt class="literal">select</tt>,
   <tt class="literal">poll</tt>, <tt class="literal">recvmsg</tt> and
   <tt class="literal">accept</tt>.</p></li>
<li><p>Signals in pthreads are now handled properly(ish):
   <tt class="literal">pthread_sigmask</tt>,
   <tt class="literal">pthread_kill</tt>, <tt class="literal">sigwait</tt>
   and <tt class="literal">raise</tt> are now implemented.  Each thread
   has its own signal mask, as POSIX requires.  It's a bit
   kludgey -- there's a system-wide pending signal set, rather
   than one for each thread.  But hey.</p></li>
</ul></div>
<p><b>Note: </b>As of 18 May 2002, the following threaded programs now work
fine on my RedHat 7.2 box: Opera 6.0Beta2, KNode in KDE 3.0,
Mozilla-0.9.2.1 and Galeon-0.11.3, both as supplied with RedHat
7.2.  Also Mozilla 1.0RC2.  OpenOffice 1.0.  MySQL 3.something
(the current stable release).</p>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="manual-core.clientreq.html">&lt;&lt; 2.7. The Client Request mechanism</a> </td>
<td width="20%" align="center"><a accesskey="u" href="manual-core.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="manual-core.signals.html">2.9. Handling of Signals &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
