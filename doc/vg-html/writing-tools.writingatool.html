<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>3.2. Writing a Tool</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="writing-tools.html" title="3. Writing a New Valgrind Tool">
<link rel="previous" href="writing-tools.html" title="3. Writing a New Valgrind Tool">
<link rel="next" href="writing-tools.advtopics.html" title="3.3. Advanced Topics">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="writing-tools.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="writing-tools.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">3. Writing a New Valgrind Tool</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="writing-tools.advtopics.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="writing-tools.writingatool"></a>3.2. Writing a Tool</h2></div></div>
<div></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.whywriteatool"></a>3.2.1. Why write a tool?</h3></div></div>
<div></div>
</div>
<p>Before you write a tool, you should have some idea of what
it should do.  What is it you want to know about your programs of
interest?  Consider some existing tools:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><span><b class="command">memcheck</b></span>: among other things, performs
  fine-grained validity and addressibility checks of every memory
  reference performed by the program.</p></li>
<li><p><span><b class="command">addrcheck</b></span>: performs lighterweight
  addressibility checks of every memory reference performed by
  the program.</p></li>
<li><p><span><b class="command">cachegrind</b></span>: tracks every instruction
  and memory reference to simulate instruction and data caches,
  tracking cache accesses and misses that occur on every line in
  the program.</p></li>
<li><p><span><b class="command">helgrind</b></span>: tracks every memory access
  and mutex lock/unlock to determine if a program contains any
  data races.</p></li>
<li><p><span><b class="command">lackey</b></span>: does simple counting of
  various things: the number of calls to a particular function
  (<tt class="computeroutput">_dl_runtime_resolve()</tt>); the
  number of basic blocks, x86 instruction, UCode instructions
  executed; the number of branches executed and the proportion of
  those which were taken.</p></li>
</ul></div>
<p>These examples give a reasonable idea of what kinds of
things Valgrind can be used for.  The instrumentation can range
from very lightweight (e.g. counting the number of times a
particular function is called) to very intrusive (e.g.
memcheck's memory checking).</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.suggestedtools"></a>3.2.2. Suggested tools</h3></div></div>
<div></div>
</div>
<p>Here is a list of ideas we have had for tools that should
not be too hard to implement.</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p><span><b class="command">branch profiler</b></span>: A machine's branch
  prediction hardware could be simulated, and each branch
  annotated with the number of predicted and mispredicted
  branches.  Would be implemented quite similarly to Cachegrind,
  and could reuse the
  <tt class="computeroutput">cg_annotate</tt> script to annotate
  source code.</p>
<p>The biggest difficulty with this is the simulation; the
  chip-makers are very cagey about how their chips do branch
  prediction.  But implementing one or more of the basic
  algorithms could still give good information.</p>
</li>
<li>
<p><span><b class="command">coverage tool</b></span>: Cachegrind can already
  be used for doing test coverage, but it's massive overkill to
  use it just for that.</p>
<p>It would be easy to write a coverage tool that records
  how many times each basic block was recorded.  Again, the
  <tt class="computeroutput">cg_annotate</tt> script could be
  used for annotating source code with the gathered information.
  Although, <tt class="computeroutput">cg_annotate</tt> is only
  designed for working with single program runs.  It could be
  extended relatively easily to deal with multiple runs of a
  program, so that the coverage of a whole test suite could be
  determined.</p>
<p>In addition to the standard coverage information, such a
  tool could record extra information that would help a user
  generate test cases to exercise unexercised paths.  For
  example, for each conditional branch, the tool could record all
  inputs to the conditional test, and print these out when
  annotating.</p>
</li>
<li>
<p><span><b class="command">run-time type checking</b></span>: A nice example
  of a dynamic checker is given in this paper:</p>
<div class="address"><p>Debugging via Run-Time Type Checking<br>
  Alexey Loginov, Suan Hsi Yong, Susan Horwitz and Thomas Reps<br>
  Proceedings of Fundamental Approaches to Software Engineering<br>
  April 2001.<br>
  </p></div>
<p>Similar is the tool described in this paper:</p>
<div class="address"><p>Run-Time Type Checking for Binary Programs<br>
  Michael Burrows, Stephen N. Freund, Janet L. Wiener<br>
  Proceedings of the 12th International Conference on Compiler Construction (CC 2003)<br>
  April 2003.<br>
  </p></div>
<p>This approach can find quite a range of bugs,
  particularly in C and C++ programs, and could be implemented
  quite nicely as a Valgrind tool.</p>
<p>Ways to speed up this run-time type checking are
  described in this paper:</p>
<div class="address"><p>Reducing the Overhead of Dynamic Analysis<br>
  Suan Hsi Yong and Susan Horwitz<br>
  Proceedings of Runtime Verification '02<br>
  July 2002.<br>
  </p></div>
<p>Valgrind's client requests could be used to pass
  information to a tool about which elements need instrumentation
  and which don't.</p>
</li>
</ul></div>
<p>We would love to hear from anyone who implements these or
other tools.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.howtoolswork"></a>3.2.3. How tools work</h3></div></div>
<div></div>
</div>
<p>Tools must define various functions for instrumenting
programs that are called by Valgrind's core, yet they must be
implemented in such a way that they can be written and compiled
without touching Valgrind's core.  This is important, because one
of our aims is to allow people to write and distribute their own
tools that can be plugged into Valgrind's core easily.</p>
<p>This is achieved by packaging each tool into a separate
shared object which is then loaded ahead of the core shared
object <tt class="computeroutput">valgrind.so</tt>, using the
dynamic linker's <tt class="computeroutput">LD_PRELOAD</tt>
variable.  Any functions defined in the tool that share the name
with a function defined in core (such as the instrumentation
function <tt class="computeroutput">instrument()</tt>)
override the core's definition.  Thus the core can call the
necessary tool functions.</p>
<p>This magic is all done for you; the shared object used is
chosen with the <tt class="computeroutput">--tool</tt> option to
the <tt class="computeroutput">valgrind</tt> startup script.
The default tool used is
<tt class="computeroutput">memcheck</tt>, Valgrind's original
memory checker.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.gettingcode"></a>3.2.4. Getting the code</h3></div></div>
<div></div>
</div>
<p>To write your own tool, you'll need to check out a copy of
Valgrind from the CVS repository, rather than using a packaged
distribution.  This is because it contains several extra files
needed for writing tools.</p>
<p>To check out the code from the CVS repository, first login:</p>
<pre class="programlisting">
cvs -d:pserver:anonymous@cvs.valgrind.sourceforge.net:/cvsroot/valgrind
login</pre>
<p>Then checkout the code.  To get a copy of the current
development version (recommended for the brave only):</p>
<pre class="programlisting">
cvs -z3 -d:pserver:anonymous@cvs.valgrind.sourceforge.net:/cvsroot/valgrind 
co valgrind</pre>
<p>To get a copy of the stable released branch:</p>
<pre class="programlisting">
cvs -z3 -d:pserver:anonymous@cvs.valgrind.sourceforge.net:/cvsroot/valgrind
co -r &lt;TAG&gt; valgrind</pre>
<p>where &lt;<tt class="computeroutput">TAG</tt>&gt; has the
form <tt class="computeroutput">VALGRIND_X_Y_Z</tt> for version
X.Y.Z.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.gettingstarted"></a>3.2.5. Getting started</h3></div></div>
<div></div>
</div>
<p>Valgrind uses GNU <tt class="computeroutput">automake</tt>
and <tt class="computeroutput">autoconf</tt> for the creation of
Makefiles and configuration.  But don't worry, these instructions
should be enough to get you started even if you know nothing
about those tools.</p>
<p>In what follows, all filenames are relative to Valgrind's
top-level directory <tt class="computeroutput">valgrind/</tt>.</p>
<div class="orderedlist"><ol type="1">
<li><p>Choose a name for the tool, and an abbreviation that can
  be used as a short prefix.  We'll use
  <tt class="computeroutput">foobar</tt> and
  <tt class="computeroutput">fb</tt> as an example.</p></li>
<li><p>Make a new directory
  <tt class="computeroutput">foobar/</tt> which will hold the
  tool.</p></li>
<li><p>Copy <tt class="computeroutput">none/Makefile.am</tt>
  into <tt class="computeroutput">foobar/</tt>.  Edit it by
  replacing all occurrences of the string
  <tt class="computeroutput">"none"</tt> with
  <tt class="computeroutput">"foobar"</tt> and the one
  occurrence of the string <tt class="computeroutput">"nl_"</tt>
  with <tt class="computeroutput">"fb_"</tt>.  It might be worth
  trying to understand this file, at least a little; you might
  have to do more complicated things with it later on.  In
  particular, the name of the
  <tt class="computeroutput">vgtool_foobar_so_SOURCES</tt>
  variable determines the name of the tool's shared object, which
  determines what name must be passed to the
  <tt class="computeroutput">--tool</tt> option to use the
  tool.</p></li>
<li><p>Copy <tt class="filename">none/nl_main.c</tt> into
  <tt class="computeroutput">foobar/</tt>, renaming it as
  <tt class="filename">fb_main.c</tt>.  Edit it by changing the lines
  in <tt class="computeroutput">pre_clo_init()</tt> to
  something appropriate for the tool.  These fields are used in
  the startup message, except for
  <tt class="computeroutput">bug_reports_to</tt> which is used
  if a tool assertion fails.</p></li>
<li><p>Edit <tt class="computeroutput">Makefile.am</tt>,
   adding the new directory
   <tt class="computeroutput">foobar</tt> to the
   <tt class="computeroutput">SUBDIRS</tt> variable.</p></li>
<li><p>Edit <tt class="computeroutput">configure.in</tt>,
   adding <tt class="computeroutput">foobar/Makefile</tt> to the
   <tt class="computeroutput">AC_OUTPUT</tt> list.</p></li>
<li>
<p>Run:</p>
<pre class="programlisting">
  autogen.sh
  ./configure --prefix=`pwd`/inst
  make install</pre>
<p>It should automake, configure and compile without
   errors, putting copies of the tool's shared object
   <tt class="computeroutput">vgtool_foobar.so</tt> in
   <tt class="computeroutput">foobar/</tt> and
   <tt class="computeroutput">inst/lib/valgrind/</tt>.</p>
</li>
<li>
<p>You can test it with a command like:</p>
<pre class="programlisting">
  inst/bin/valgrind --tool=foobar date</pre>
<p>(almost any program should work;
   <tt class="computeroutput">date</tt> is just an example).
   The output should be something like this:</p>
<pre class="programlisting">
  ==738== foobar-0.0.1, a foobarring tool for x86-linux.
  ==738== Copyright (C) 1066AD, and GNU GPL'd, by J. Random Hacker.
  ==738== Built with valgrind-1.1.0, a program execution monitor.
  ==738== Copyright (C) 2000-2003, and GNU GPL'd, by Julian Seward.
  ==738== Estimated CPU clock rate is 1400 MHz
  ==738== For more details, rerun with: -v
  ==738== Wed Sep 25 10:31:54 BST 2002
  ==738==</pre>
<p>The tool does nothing except run the program
   uninstrumented.</p>
</li>
</ol></div>
<p>These steps don't have to be followed exactly - you can
choose different names for your source files, and use a different
<tt class="computeroutput">--prefix</tt> for
<tt class="computeroutput">./configure</tt>.</p>
<p>Now that we've setup, built and tested the simplest
possible tool, onto the interesting stuff...</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.writingcode"></a>3.2.6. Writing the code</h3></div></div>
<div></div>
</div>
<p>A tool must define at least these four functions:</p>
<pre class="programlisting">
  pre_clo_init()
  post_clo_init()
  instrument()
  fini()</pre>
<p>Also, it must use the macro
<tt class="computeroutput">VG_DETERMINE_INTERFACE_VERSION</tt>
exactly once in its source code.  If it doesn't, you will get a
link error involving
<tt class="computeroutput">VG_(tool_interface_version)</tt>.
This macro is used to ensure the core/tool interface used by the
core and a plugged-in tool are binary compatible.</p>
<p>In addition, if a tool wants to use some of the optional
services provided by the core, it may have to define other
functions.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.init"></a>3.2.7. Initialisation</h3></div></div>
<div></div>
</div>
<p>Most of the initialisation should be done in
<tt class="computeroutput">pre_clo_init()</tt>.  Only use
<tt class="computeroutput">post_clo_init()</tt> if a tool
provides command line options and must do some initialisation
after option processing takes place
(<tt class="computeroutput">"clo"</tt> stands for "command line
options").</p>
<p>First of all, various "details" need to be set for a tool,
using the functions
<tt class="computeroutput">VG_(details_*)()</tt>.  Some are all
compulsory, some aren't.  Some are used when constructing the
startup message,
<tt class="computeroutput">detail_bug_reports_to</tt> is used if
<tt class="computeroutput">VG_(tool_panic)()</tt> is ever
called, or a tool assertion fails.  Others have other uses.</p>
<p>Second, various "needs" can be set for a tool, using the
functions <tt class="computeroutput">VG_(needs_*)()</tt>.  They
are mostly booleans, and can be left untouched (they default to
<tt class="computeroutput">False</tt>).  They determine whether
a tool can do various things such as: record, report and suppress
errors; process command line options; wrap system calls; record
extra information about malloc'd blocks, etc.</p>
<p>For example, if a tool wants the core's help in recording
and reporting errors, it must set the
<tt class="computeroutput">tool_errors</tt> need to
<tt class="computeroutput">True</tt>, and then provide
definitions of six functions for comparing errors, printing out
errors, reading suppressions from a suppressions file, etc.
While writing these functions requires some work, it's much less
than doing error handling from scratch because the core is doing
most of the work.  See the type
<tt class="computeroutput">VgNeeds</tt> in
<tt class="filename">include/tool.h</tt> for full details of all
the needs.</p>
<p>Third, the tool can indicate which events in core it wants
to be notified about, using the functions
<tt class="computeroutput">VG_(track_*)()</tt>.  These include
things such as blocks of memory being malloc'd, the stack pointer
changing, a mutex being locked, etc.  If a tool wants to know
about this, it should set the relevant pointer in the structure
to point to a function, which will be called when that event
happens.</p>
<p>For example, if the tool want to be notified when a new
block of memory is malloc'd, it should call
<tt class="computeroutput">VG_(track_new_mem_heap)()</tt> with
an appropriate function pointer, and the assigned function will
be called each time this happens.</p>
<p>More information about "details", "needs" and "trackable
events" can be found in
<tt class="filename">include/tool.h</tt>.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.instr"></a>3.2.8. Instrumentation</h3></div></div>
<div></div>
</div>
<p><tt class="computeroutput">instrument()</tt> is the
interesting one.  It allows you to instrument
<span class="emphasis"><em>UCode</em></span>, which is Valgrind's RISC-like
intermediate language.  UCode is described in 
<a href="mc-tech-docs.jitter.html#mc-tech-docs.ucode">Introduction to UCode</a>.</p>
<p>The easiest way to instrument UCode is to insert calls to C
functions when interesting things happen.  See the tool "Lackey"
(<tt class="filename">lackey/lk_main.c</tt>) for a simple example of
this, or Cachegrind (<tt class="filename">cachegrind/cg_main.c</tt>)
for a more complex example.</p>
<p>A much more complicated way to instrument UCode, albeit one
that might result in faster instrumented programs, is to extend
UCode with new UCode instructions.  This is recommended for
advanced Valgrind hackers only!  See Memcheck for an example.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.fini"></a>3.2.9. Finalisation</h3></div></div>
<div></div>
</div>
<p>This is where you can present the final results, such as a
summary of the information collected.  Any log files should be
written out at this point.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.otherinfo"></a>3.2.10. Other Important Information</h3></div></div>
<div></div>
</div>
<p>Please note that the core/tool split infrastructure is
quite complex and not brilliantly documented.  Here are some
important points, but there are undoubtedly many others that I
should note but haven't thought of.</p>
<p>The file <tt class="filename">include/tool.h</tt> contains
all the types, macros, functions, etc. that a tool should
(hopefully) need, and is the only <tt class="filename">.h</tt> file a
tool should need to
<tt class="computeroutput">#include</tt>.</p>
<p>In particular, you probably shouldn't use anything from the
C library (there are deep reasons for this, trust us).  Valgrind
provides an implementation of a reasonable subset of the C
library, details of which are in
<tt class="filename">tool.h</tt>.</p>
<p>Similarly, when writing a tool, you shouldn't need to look
at any of the code in Valgrind's core.  Although it might be
useful sometimes to help understand something.</p>
<p><tt class="filename">tool.h</tt> has a reasonable amount of
documentation in it that should hopefully be enough to get you
going.  But ultimately, the tools distributed (Memcheck,
Addrcheck, Cachegrind, Lackey, etc.) are probably the best
documentation of all, for the moment.</p>
<p>Note that the <tt class="computeroutput">VG_</tt> and
<tt class="computeroutput">TL_</tt> macros are used heavily.
These just prepend longer strings in front of names to avoid
potential namespace clashes.  We strongly recommend using the
<tt class="computeroutput">TL_</tt> macro for any global
functions and variables in your tool, or writing a similar
macro.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="writing-tools.advice"></a>3.2.11. Words of Advice</h3></div></div>
<div></div>
</div>
<p>Writing and debugging tools is not trivial.  Here are some
suggestions for solving common problems.</p>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="writing-tools.segfaults"></a>3.2.11.1. Segmentation Faults</h4></div></div>
<div></div>
</div>
<p>If you are getting segmentation faults in C functions used
by your tool, the usual GDB command:</p>
<pre class="screen">
  gdb &lt;prog&gt; core</pre>
<p>usually gives the location of the segmentation fault.</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="writing-tools.debugfns"></a>3.2.11.2. Debugging C functions</h4></div></div>
<div></div>
</div>
<p>If you want to debug C functions used by your tool, you can
attach GDB to Valgrind with some effort:</p>
<div class="orderedlist"><ol type="1">
<li>
<p>Enable the following code in
  <tt class="filename">coregrind/vg_main.c</tt> by changing
  <tt class="computeroutput">if (0)</tt> 
  into <tt class="computeroutput">if (1)</tt>:
</p>
<pre class="programlisting">
  /* Hook to delay things long enough so we can get the pid and
     attach GDB in another shell. */
  if (0) { 
    Int p, q;
    for ( p = 0; p &lt; 50000; p++ )
      for ( q = 0; q &lt; 50000; q++ ) ;
  }</pre>
<p>
  and rebuild Valgrind.</p>
</li>
<li>
<p>Then run:</p>
<pre class="programlisting">
  valgrind &lt;prog&gt;</pre>
<p>Valgrind starts the program, printing its process id, and
  then delays for a few seconds (you may have to change the loop
  bounds to get a suitable delay).</p>
</li>
<li>
<p>In a second shell run:</p>
<pre class="programlisting">
  gdb &lt;prog pid&gt;</pre>
</li>
</ol></div>
<p>GDB may be able to give you useful information.  Note that
by default most of the system is built with
<tt class="computeroutput">-fomit-frame-pointer</tt>, and you'll
need to get rid of this to extract useful tracebacks from GDB.</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="writing-tools.ucode-probs"></a>3.2.11.3. UCode Instrumentation Problems</h4></div></div>
<div></div>
</div>
<p>If you are having problems with your UCode instrumentation,
it's likely that GDB won't be able to help at all.  In this case,
Valgrind's <tt class="computeroutput">--trace-codegen</tt>
option is invaluable for observing the results of
instrumentation.</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="writing-tools.misc"></a>3.2.11.4. Miscellaneous</h4></div></div>
<div></div>
</div>
<p>If you just want to know whether a program point has been
reached, using the <tt class="computeroutput">OINK</tt> macro
(in <tt class="filename">include/tool.h</tt>) can be easier than
using GDB.</p>
<p>The other debugging command line options can be useful too
(run <tt class="computeroutput">valgrind -h</tt> for the
list).</p>
</div>
</div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="writing-tools.html">&lt;&lt; 3. Writing a New Valgrind Tool</a> </td>
<td width="20%" align="center"><a accesskey="u" href="writing-tools.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="writing-tools.advtopics.html">3.3. Advanced Topics &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
