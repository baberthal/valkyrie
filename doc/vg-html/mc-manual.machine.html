<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>3.5. Details of Memcheck's checking machinery</title>
<link rel="stylesheet" href="vg_basic.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="mc-manual.html" title="3. Memcheck: a heavyweight memory checker">
<link rel="previous" href="mc-manual.suppfiles.html" title="3.4. Writing suppressions files">
<link rel="next" href="mc-manual.leaks.html" title="3.6. Memory leak detection">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="mc-manual.suppfiles.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="mc-manual.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">3. Memcheck: a heavyweight memory checker</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="mc-manual.leaks.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="mc-manual.machine"></a>3.5. Details of Memcheck's checking machinery</h2></div></div>
<div></div>
</div>
<p>Read this section if you want to know, in detail, exactly
what and how Memcheck is checking.</p>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.value"></a>3.5.1. Valid-value (V) bits</h3></div></div>
<div></div>
</div>
<p>It is simplest to think of Memcheck implementing a
synthetic Intel x86 CPU which is identical to a real CPU, except
for one crucial detail.  Every bit (literally) of data processed,
stored and handled by the real CPU has, in the synthetic CPU, an
associated "valid-value" bit, which says whether or not the
accompanying bit has a legitimate value.  In the discussions
which follow, this bit is referred to as the V (valid-value)
bit.</p>
<p>Each byte in the system therefore has a 8 V bits which
follow it wherever it goes.  For example, when the CPU loads a
word-size item (4 bytes) from memory, it also loads the
corresponding 32 V bits from a bitmap which stores the V bits for
the process' entire address space.  If the CPU should later write
the whole or some part of that value to memory at a different
address, the relevant V bits will be stored back in the V-bit
bitmap.</p>
<p>In short, each bit in the system has an associated V bit,
which follows it around everywhere, even inside the CPU.  Yes,
the CPU's (integer and <tt class="computeroutput">%eflags</tt>)
registers have their own V bit vectors.</p>
<p>Copying values around does not cause Memcheck to check for,
or report on, errors.  However, when a value is used in a way
which might conceivably affect the outcome of your program's
computation, the associated V bits are immediately checked.  If
any of these indicate that the value is undefined, an error is
reported.</p>
<p>Here's an (admittedly nonsensical) example:</p>
<pre class="programlisting">
int i, j;
int a[10], b[10];
for ( i = 0; i &lt; 10; i++ ) {
  j = a[i];
  b[i] = j;
}</pre>
<p>Memcheck emits no complaints about this, since it merely
copies uninitialised values from
<tt class="computeroutput">a[]</tt> into
<tt class="computeroutput">b[]</tt>, and doesn't use them in any
way.  However, if the loop is changed to:</p>
<pre class="programlisting">
for ( i = 0; i &lt; 10; i++ ) {
  j += a[i];
}
if ( j == 77 ) 
  printf("hello there\n");
</pre>
<p>then Valgrind will complain, at the
<tt class="computeroutput">if</tt>, that the condition depends
on uninitialised values.  Note that it <span><b class="command">doesn't</b></span>
complain at the <tt class="computeroutput">j += a[i];</tt>,
since at that point the undefinedness is not "observable".  It's
only when a decision has to be made as to whether or not to do
the <tt class="computeroutput">printf</tt> -- an observable
action of your program -- that Memcheck complains.</p>
<p>Most low level operations, such as adds, cause Memcheck to
use the <tt class="literal">V bits</tt> for the operands to calculate
the V bits for the result.  Even if the result is partially or
wholly undefined, it does not complain.</p>
<p>Checks on definedness only occur in two places: when a
value is used to generate a memory address, and where control
flow decision needs to be made.  Also, when a system call is
detected, valgrind checks definedness of parameters as
required.</p>
<p>If a check should detect undefinedness, an error message is
issued.  The resulting value is subsequently regarded as
well-defined.  To do otherwise would give long chains of error
messages.  In effect, we say that undefined values are
non-infectious.</p>
<p>This sounds overcomplicated.  Why not just check all reads
from memory, and complain if an undefined value is loaded into a
CPU register?  Well, that doesn't work well, because perfectly
legitimate C programs routinely copy uninitialised values around
in memory, and we don't want endless complaints about that.
Here's the canonical example.  Consider a struct like
this:</p>
<pre class="programlisting">
struct S { int x; char c; };
struct S s1, s2;
s1.x = 42;
s1.c = 'z';
s2 = s1;
</pre>
<p>The question to ask is: how large is <tt class="computeroutput">struct
S</tt>, in bytes?  An
<tt class="computeroutput">int</tt> is 4 bytes and a
<tt class="computeroutput">char</tt> one byte, so perhaps a
<tt class="computeroutput">struct S</tt> occupies 5 bytes?
Wrong.  All (non-toy) compilers we know of will round the size of
<tt class="computeroutput">struct S</tt> up to a whole number of
words, in this case 8 bytes.  Not doing this forces compilers to
generate truly appalling code for subscripting arrays of
<tt class="computeroutput">struct S</tt>'s.</p>
<p>So <tt class="computeroutput">s1</tt> occupies 8 bytes,
yet only 5 of them will be initialised.  For the assignment
<tt class="computeroutput">s2 = s1</tt>, gcc generates code to
copy all 8 bytes wholesale into
<tt class="computeroutput">s2</tt> without regard for their
meaning.  If Memcheck simply checked values as they came out of
memory, it would yelp every time a structure assignment like this
happened.  So the more complicated semantics described above is
necessary.  This allows <tt class="literal">gcc</tt> to copy
<tt class="computeroutput">s1</tt> into
<tt class="computeroutput">s2</tt> any way it likes, and a
warning will only be emitted if the uninitialised values are
later used.</p>
<p>One final twist to this story.  The above scheme allows
garbage to pass through the CPU's integer registers without
complaint.  It does this by giving the integer registers
<tt class="literal">V</tt> tags, passing these around in the expected
way.  This complicated and computationally expensive to do, but
is necessary.  Memcheck is more simplistic about floating-point
loads and stores.  In particular, <tt class="literal">V</tt> bits for
data read as a result of floating-point loads are checked at the
load instruction.  So if your program uses the floating-point
registers to do memory-to-memory copies, you will get complaints
about uninitialised values.  Fortunately, I have not yet
encountered a program which (ab)uses the floating-point registers
in this way.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.vaddress"></a>3.5.2. Valid-address (A) bits</h3></div></div>
<div></div>
</div>
<p>Notice that the previous subsection describes how the
validity of values is established and maintained without having
to say whether the program does or does not have the right to
access any particular memory location.  We now consider the
latter issue.</p>
<p>As described above, every bit in memory or in the CPU has
an associated valid-value (<tt class="literal">V</tt>) bit.  In
addition, all bytes in memory, but not in the CPU, have an
associated valid-address (<tt class="literal">A</tt>) bit.  This
indicates whether or not the program can legitimately read or
write that location.  It does not give any indication of the
validity or the data at that location -- that's the job of the
<tt class="literal">V</tt> bits -- only whether or not the location may
be accessed.</p>
<p>Every time your program reads or writes memory, Memcheck
checks the <tt class="literal">A</tt> bits associated with the address.
If any of them indicate an invalid address, an error is emitted.
Note that the reads and writes themselves do not change the A
bits, only consult them.</p>
<p>So how do the <tt class="literal">A</tt> bits get set/cleared?
Like this:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>When the program starts, all the global data areas are
    marked as accessible.</p></li>
<li><p>When the program does malloc/new, the A bits for
    exactly the area allocated, and not a byte more, are marked
    as accessible.  Upon freeing the area the A bits are changed
    to indicate inaccessibility.</p></li>
<li><p>When the stack pointer register
    (<tt class="literal">%esp</tt>) moves up or down,
    <tt class="literal">A</tt> bits are set.  The rule is that the area
    from <tt class="literal">%esp</tt> up to the base of the stack is
    marked as accessible, and below <tt class="literal">%esp</tt> is
    inaccessible.  (If that sounds illogical, bear in mind that
    the stack grows down, not up, on almost all Unix systems,
    including GNU/Linux.)  Tracking <tt class="literal">%esp</tt> like
    this has the useful side-effect that the section of stack
    used by a function for local variables etc is automatically
    marked accessible on function entry and inaccessible on
    exit.</p></li>
<li><p>When doing system calls, A bits are changed
    appropriately.  For example, mmap() magically makes files
    appear in the process's address space, so the A bits must be
    updated if mmap() succeeds.</p></li>
<li><p>Optionally, your program can tell Valgrind about such
    changes explicitly, using the client request mechanism
    described above.</p></li>
</ul></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="mc-manual.together"></a>3.5.3. Putting it all together</h3></div></div>
<div></div>
</div>
<p>Memcheck's checking machinery can be summarised as
follows:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Each byte in memory has 8 associated
    <tt class="literal">V</tt> (valid-value) bits, saying whether or
    not the byte has a defined value, and a single
    <tt class="literal">A</tt> (valid-address) bit, saying whether or
    not the program currently has the right to read/write that
    address.</p></li>
<li><p>When memory is read or written, the relevant
    <tt class="literal">A</tt> bits are consulted.  If they indicate an
    invalid address, Valgrind emits an Invalid read or Invalid
    write error.</p></li>
<li><p>When memory is read into the CPU's integer registers,
    the relevant <tt class="literal">V</tt> bits are fetched from
    memory and stored in the simulated CPU.  They are not
    consulted.</p></li>
<li><p>When an integer register is written out to memory, the
    <tt class="literal">V</tt> bits for that register are written back
    to memory too.</p></li>
<li><p>When memory is read into the CPU's floating point
    registers, the relevant <tt class="literal">V</tt> bits are read
    from memory and they are immediately checked.  If any are
    invalid, an uninitialised value error is emitted.  This
    precludes using the floating-point registers to copy
    possibly-uninitialised memory, but simplifies Valgrind in
    that it does not have to track the validity status of the
    floating-point registers.</p></li>
<li><p>As a result, when a floating-point register is written
    to memory, the associated V bits are set to indicate a valid
    value.</p></li>
<li><p>When values in integer CPU registers are used to
    generate a memory address, or to determine the outcome of a
    conditional branch, the <tt class="literal">V</tt> bits for those
    values are checked, and an error emitted if any of them are
    undefined.</p></li>
<li><p>When values in integer CPU registers are used for any
    other purpose, Valgrind computes the V bits for the result,
    but does not check them.</p></li>
<li><p>One the <tt class="literal">V</tt> bits for a value in the
    CPU have been checked, they are then set to indicate
    validity.  This avoids long chains of errors.</p></li>
<li>
<p>When values are loaded from memory, valgrind checks the
    A bits for that location and issues an illegal-address
    warning if needed.  In that case, the V bits loaded are
    forced to indicate Valid, despite the location being invalid.</p>
<p>This apparently strange choice reduces the amount of
    confusing information presented to the user.  It avoids the
    unpleasant phenomenon in which memory is read from a place
    which is both unaddressible and contains invalid values, and,
    as a result, you get not only an invalid-address (read/write)
    error, but also a potentially large set of
    uninitialised-value errors, one for every time the value is
    used.</p>
<p>There is a hazy boundary case to do with multi-byte
    loads from addresses which are partially valid and partially
    invalid.  See details of the flag
    <tt class="computeroutput">--partial-loads-ok</tt> for
    details.  </p>
</li>
</ul></div>
<p>Memcheck intercepts calls to malloc, calloc, realloc,
valloc, memalign, free, new and delete.  The behaviour you get
is:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>malloc/new: the returned memory is marked as
    addressible but not having valid values.  This means you have
    to write on it before you can read it.</p></li>
<li><p>calloc: returned memory is marked both addressible and
    valid, since calloc() clears the area to zero.</p></li>
<li><p>realloc: if the new size is larger than the old, the
    new section is addressible but invalid, as with
    malloc.</p></li>
<li><p>If the new size is smaller, the dropped-off section is
    marked as unaddressible.  You may only pass to realloc a
    pointer previously issued to you by malloc/calloc/realloc.</p></li>
<li><p>free/delete: you may only pass to free a pointer
    previously issued to you by malloc/calloc/realloc, or the
    value NULL. Otherwise, Valgrind complains.  If the pointer is
    indeed valid, Valgrind marks the entire area it points at as
    unaddressible, and places the block in the
    freed-blocks-queue.  The aim is to defer as long as possible
    reallocation of this block.  Until that happens, all attempts
    to access it will elicit an invalid-address error, as you
    would hope.</p></li>
</ul></div>
</div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="mc-manual.suppfiles.html">&lt;&lt; 3.4. Writing suppressions files</a> </td>
<td width="20%" align="center"><a accesskey="u" href="mc-manual.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="mc-manual.leaks.html">3.6. Memory leak detection &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
